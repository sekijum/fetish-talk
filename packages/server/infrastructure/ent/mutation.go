// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"server/infrastructure/ent/adminuser"
	"server/infrastructure/ent/comment"
	"server/infrastructure/ent/commentattachment"
	"server/infrastructure/ent/forum"
	"server/infrastructure/ent/predicate"
	"server/infrastructure/ent/topic"
	"server/infrastructure/ent/topictag"
	"server/infrastructure/ent/topictagging"
	"server/infrastructure/ent/user"
	"server/infrastructure/ent/usercommentlike"
	"server/infrastructure/ent/usercommentsubscription"
	"server/infrastructure/ent/userforumlike"
	"server/infrastructure/ent/userforumsubscription"
	"server/infrastructure/ent/usertopiclike"
	"server/infrastructure/ent/usertopicsubscription"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdminUser               = "AdminUser"
	TypeComment                 = "Comment"
	TypeCommentAttachment       = "CommentAttachment"
	TypeForum                   = "Forum"
	TypeTopic                   = "Topic"
	TypeTopicTag                = "TopicTag"
	TypeTopicTagging            = "TopicTagging"
	TypeUser                    = "User"
	TypeUserCommentLike         = "UserCommentLike"
	TypeUserCommentSubscription = "UserCommentSubscription"
	TypeUserForumLike           = "UserForumLike"
	TypeUserForumSubscription   = "UserForumSubscription"
	TypeUserTopicLike           = "UserTopicLike"
	TypeUserTopicSubscription   = "UserTopicSubscription"
)

// AdminUserMutation represents an operation that mutates the AdminUser nodes in the graph.
type AdminUserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	userName      *string
	email         *string
	password      *string
	createdAt     *time.Time
	updatedAt     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AdminUser, error)
	predicates    []predicate.AdminUser
}

var _ ent.Mutation = (*AdminUserMutation)(nil)

// adminuserOption allows management of the mutation configuration using functional options.
type adminuserOption func(*AdminUserMutation)

// newAdminUserMutation creates new mutation for the AdminUser entity.
func newAdminUserMutation(c config, op Op, opts ...adminuserOption) *AdminUserMutation {
	m := &AdminUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminUserID sets the ID field of the mutation.
func withAdminUserID(id int) adminuserOption {
	return func(m *AdminUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminUser
		)
		m.oldValue = func(ctx context.Context) (*AdminUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminUser sets the old AdminUser of the mutation.
func withAdminUser(node *AdminUser) adminuserOption {
	return func(m *AdminUserMutation) {
		m.oldValue = func(context.Context) (*AdminUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminUser entities.
func (m *AdminUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserName sets the "userName" field.
func (m *AdminUserMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *AdminUserMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName resets all changes to the "userName" field.
func (m *AdminUserMutation) ResetUserName() {
	m.userName = nil
}

// SetEmail sets the "email" field.
func (m *AdminUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AdminUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AdminUserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *AdminUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminUserMutation) ResetPassword() {
	m.password = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *AdminUserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AdminUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AdminUserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *AdminUserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *AdminUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *AdminUserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// Where appends a list predicates to the AdminUserMutation builder.
func (m *AdminUserMutation) Where(ps ...predicate.AdminUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminUser).
func (m *AdminUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminUserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.userName != nil {
		fields = append(fields, adminuser.FieldUserName)
	}
	if m.email != nil {
		fields = append(fields, adminuser.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, adminuser.FieldPassword)
	}
	if m.createdAt != nil {
		fields = append(fields, adminuser.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, adminuser.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldUserName:
		return m.UserName()
	case adminuser.FieldEmail:
		return m.Email()
	case adminuser.FieldPassword:
		return m.Password()
	case adminuser.FieldCreatedAt:
		return m.CreatedAt()
	case adminuser.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminuser.FieldUserName:
		return m.OldUserName(ctx)
	case adminuser.FieldEmail:
		return m.OldEmail(ctx)
	case adminuser.FieldPassword:
		return m.OldPassword(ctx)
	case adminuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case adminuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case adminuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case adminuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdminUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminUserMutation) ResetField(name string) error {
	switch name {
	case adminuser.FieldUserName:
		m.ResetUserName()
		return nil
	case adminuser.FieldEmail:
		m.ResetEmail()
		return nil
	case adminuser.FieldPassword:
		m.ResetPassword()
		return nil
	case adminuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AdminUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AdminUser edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	guestName                  *string
	message                    *string
	status                     *comment.Status
	createdAt                  *time.Time
	updatedAt                  *time.Time
	clearedFields              map[string]struct{}
	topic                      *int
	clearedtopic               bool
	author                     *int
	clearedauthor              bool
	parent                     *int
	clearedparent              bool
	replies                    map[int]struct{}
	removedreplies             map[int]struct{}
	clearedreplies             bool
	comment_attachments        map[int]struct{}
	removedcomment_attachments map[int]struct{}
	clearedcomment_attachments bool
	liked_users                map[int]struct{}
	removedliked_users         map[int]struct{}
	clearedliked_users         bool
	subscribed_users           map[int]struct{}
	removedsubscribed_users    map[int]struct{}
	clearedsubscribed_users    bool
	done                       bool
	oldValue                   func(context.Context) (*Comment, error)
	predicates                 []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTopicId sets the "topicId" field.
func (m *CommentMutation) SetTopicId(i int) {
	m.topic = &i
}

// TopicId returns the value of the "topicId" field in the mutation.
func (m *CommentMutation) TopicId() (r int, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopicId returns the old "topicId" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldTopicId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopicId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopicId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopicId: %w", err)
	}
	return oldValue.TopicId, nil
}

// ResetTopicId resets all changes to the "topicId" field.
func (m *CommentMutation) ResetTopicId() {
	m.topic = nil
}

// SetParentId sets the "parentId" field.
func (m *CommentMutation) SetParentId(i int) {
	m.parent = &i
}

// ParentId returns the value of the "parentId" field in the mutation.
func (m *CommentMutation) ParentId() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentId returns the old "parentId" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentId: %w", err)
	}
	return oldValue.ParentId, nil
}

// ClearParentId clears the value of the "parentId" field.
func (m *CommentMutation) ClearParentId() {
	m.parent = nil
	m.clearedFields[comment.FieldParentId] = struct{}{}
}

// ParentIdCleared returns if the "parentId" field was cleared in this mutation.
func (m *CommentMutation) ParentIdCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentId]
	return ok
}

// ResetParentId resets all changes to the "parentId" field.
func (m *CommentMutation) ResetParentId() {
	m.parent = nil
	delete(m.clearedFields, comment.FieldParentId)
}

// SetUserId sets the "userId" field.
func (m *CommentMutation) SetUserId(i int) {
	m.author = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *CommentMutation) UserId() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "userId" field.
func (m *CommentMutation) ClearUserId() {
	m.author = nil
	m.clearedFields[comment.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *CommentMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *CommentMutation) ResetUserId() {
	m.author = nil
	delete(m.clearedFields, comment.FieldUserId)
}

// SetGuestName sets the "guestName" field.
func (m *CommentMutation) SetGuestName(s string) {
	m.guestName = &s
}

// GuestName returns the value of the "guestName" field in the mutation.
func (m *CommentMutation) GuestName() (r string, exists bool) {
	v := m.guestName
	if v == nil {
		return
	}
	return *v, true
}

// OldGuestName returns the old "guestName" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldGuestName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuestName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuestName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuestName: %w", err)
	}
	return oldValue.GuestName, nil
}

// ClearGuestName clears the value of the "guestName" field.
func (m *CommentMutation) ClearGuestName() {
	m.guestName = nil
	m.clearedFields[comment.FieldGuestName] = struct{}{}
}

// GuestNameCleared returns if the "guestName" field was cleared in this mutation.
func (m *CommentMutation) GuestNameCleared() bool {
	_, ok := m.clearedFields[comment.FieldGuestName]
	return ok
}

// ResetGuestName resets all changes to the "guestName" field.
func (m *CommentMutation) ResetGuestName() {
	m.guestName = nil
	delete(m.clearedFields, comment.FieldGuestName)
}

// SetMessage sets the "message" field.
func (m *CommentMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CommentMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CommentMutation) ResetMessage() {
	m.message = nil
}

// SetStatus sets the "status" field.
func (m *CommentMutation) SetStatus(c comment.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentMutation) Status() (r comment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldStatus(ctx context.Context) (v comment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetTopicID sets the "topic" edge to the Topic entity by id.
func (m *CommentMutation) SetTopicID(id int) {
	m.topic = &id
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *CommentMutation) ClearTopic() {
	m.clearedtopic = true
	m.clearedFields[comment.FieldTopicId] = struct{}{}
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *CommentMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicID returns the "topic" edge ID in the mutation.
func (m *CommentMutation) TopicID() (id int, exists bool) {
	if m.topic != nil {
		return *m.topic, true
	}
	return
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) TopicIDs() (ids []int) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *CommentMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *CommentMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *CommentMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[comment.FieldUserId] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *CommentMutation) AuthorCleared() bool {
	return m.UserIdCleared() || m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CommentMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CommentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetParentID sets the "parent" edge to the Comment entity by id.
func (m *CommentMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Comment entity.
func (m *CommentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[comment.FieldParentId] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCleared() bool {
	return m.ParentIdCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CommentMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddReplyIDs adds the "replies" edge to the Comment entity by ids.
func (m *CommentMutation) AddReplyIDs(ids ...int) {
	if m.replies == nil {
		m.replies = make(map[int]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Comment entity.
func (m *CommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Comment entity was cleared.
func (m *CommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveReplyIDs(ids ...int) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Comment entity.
func (m *CommentMutation) RemovedRepliesIDs() (ids []int) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *CommentMutation) RepliesIDs() (ids []int) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *CommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// AddCommentAttachmentIDs adds the "comment_attachments" edge to the CommentAttachment entity by ids.
func (m *CommentMutation) AddCommentAttachmentIDs(ids ...int) {
	if m.comment_attachments == nil {
		m.comment_attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.comment_attachments[ids[i]] = struct{}{}
	}
}

// ClearCommentAttachments clears the "comment_attachments" edge to the CommentAttachment entity.
func (m *CommentMutation) ClearCommentAttachments() {
	m.clearedcomment_attachments = true
}

// CommentAttachmentsCleared reports if the "comment_attachments" edge to the CommentAttachment entity was cleared.
func (m *CommentMutation) CommentAttachmentsCleared() bool {
	return m.clearedcomment_attachments
}

// RemoveCommentAttachmentIDs removes the "comment_attachments" edge to the CommentAttachment entity by IDs.
func (m *CommentMutation) RemoveCommentAttachmentIDs(ids ...int) {
	if m.removedcomment_attachments == nil {
		m.removedcomment_attachments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comment_attachments, ids[i])
		m.removedcomment_attachments[ids[i]] = struct{}{}
	}
}

// RemovedCommentAttachments returns the removed IDs of the "comment_attachments" edge to the CommentAttachment entity.
func (m *CommentMutation) RemovedCommentAttachmentsIDs() (ids []int) {
	for id := range m.removedcomment_attachments {
		ids = append(ids, id)
	}
	return
}

// CommentAttachmentsIDs returns the "comment_attachments" edge IDs in the mutation.
func (m *CommentMutation) CommentAttachmentsIDs() (ids []int) {
	for id := range m.comment_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetCommentAttachments resets all changes to the "comment_attachments" edge.
func (m *CommentMutation) ResetCommentAttachments() {
	m.comment_attachments = nil
	m.clearedcomment_attachments = false
	m.removedcomment_attachments = nil
}

// AddLikedUserIDs adds the "liked_users" edge to the User entity by ids.
func (m *CommentMutation) AddLikedUserIDs(ids ...int) {
	if m.liked_users == nil {
		m.liked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_users[ids[i]] = struct{}{}
	}
}

// ClearLikedUsers clears the "liked_users" edge to the User entity.
func (m *CommentMutation) ClearLikedUsers() {
	m.clearedliked_users = true
}

// LikedUsersCleared reports if the "liked_users" edge to the User entity was cleared.
func (m *CommentMutation) LikedUsersCleared() bool {
	return m.clearedliked_users
}

// RemoveLikedUserIDs removes the "liked_users" edge to the User entity by IDs.
func (m *CommentMutation) RemoveLikedUserIDs(ids ...int) {
	if m.removedliked_users == nil {
		m.removedliked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_users, ids[i])
		m.removedliked_users[ids[i]] = struct{}{}
	}
}

// RemovedLikedUsers returns the removed IDs of the "liked_users" edge to the User entity.
func (m *CommentMutation) RemovedLikedUsersIDs() (ids []int) {
	for id := range m.removedliked_users {
		ids = append(ids, id)
	}
	return
}

// LikedUsersIDs returns the "liked_users" edge IDs in the mutation.
func (m *CommentMutation) LikedUsersIDs() (ids []int) {
	for id := range m.liked_users {
		ids = append(ids, id)
	}
	return
}

// ResetLikedUsers resets all changes to the "liked_users" edge.
func (m *CommentMutation) ResetLikedUsers() {
	m.liked_users = nil
	m.clearedliked_users = false
	m.removedliked_users = nil
}

// AddSubscribedUserIDs adds the "subscribed_users" edge to the User entity by ids.
func (m *CommentMutation) AddSubscribedUserIDs(ids ...int) {
	if m.subscribed_users == nil {
		m.subscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_users[ids[i]] = struct{}{}
	}
}

// ClearSubscribedUsers clears the "subscribed_users" edge to the User entity.
func (m *CommentMutation) ClearSubscribedUsers() {
	m.clearedsubscribed_users = true
}

// SubscribedUsersCleared reports if the "subscribed_users" edge to the User entity was cleared.
func (m *CommentMutation) SubscribedUsersCleared() bool {
	return m.clearedsubscribed_users
}

// RemoveSubscribedUserIDs removes the "subscribed_users" edge to the User entity by IDs.
func (m *CommentMutation) RemoveSubscribedUserIDs(ids ...int) {
	if m.removedsubscribed_users == nil {
		m.removedsubscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_users, ids[i])
		m.removedsubscribed_users[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedUsers returns the removed IDs of the "subscribed_users" edge to the User entity.
func (m *CommentMutation) RemovedSubscribedUsersIDs() (ids []int) {
	for id := range m.removedsubscribed_users {
		ids = append(ids, id)
	}
	return
}

// SubscribedUsersIDs returns the "subscribed_users" edge IDs in the mutation.
func (m *CommentMutation) SubscribedUsersIDs() (ids []int) {
	for id := range m.subscribed_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedUsers resets all changes to the "subscribed_users" edge.
func (m *CommentMutation) ResetSubscribedUsers() {
	m.subscribed_users = nil
	m.clearedsubscribed_users = false
	m.removedsubscribed_users = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.topic != nil {
		fields = append(fields, comment.FieldTopicId)
	}
	if m.parent != nil {
		fields = append(fields, comment.FieldParentId)
	}
	if m.author != nil {
		fields = append(fields, comment.FieldUserId)
	}
	if m.guestName != nil {
		fields = append(fields, comment.FieldGuestName)
	}
	if m.message != nil {
		fields = append(fields, comment.FieldMessage)
	}
	if m.status != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldTopicId:
		return m.TopicId()
	case comment.FieldParentId:
		return m.ParentId()
	case comment.FieldUserId:
		return m.UserId()
	case comment.FieldGuestName:
		return m.GuestName()
	case comment.FieldMessage:
		return m.Message()
	case comment.FieldStatus:
		return m.Status()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldTopicId:
		return m.OldTopicId(ctx)
	case comment.FieldParentId:
		return m.OldParentId(ctx)
	case comment.FieldUserId:
		return m.OldUserId(ctx)
	case comment.FieldGuestName:
		return m.OldGuestName(ctx)
	case comment.FieldMessage:
		return m.OldMessage(ctx)
	case comment.FieldStatus:
		return m.OldStatus(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldTopicId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicId(v)
		return nil
	case comment.FieldParentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentId(v)
		return nil
	case comment.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case comment.FieldGuestName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuestName(v)
		return nil
	case comment.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(comment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldParentId) {
		fields = append(fields, comment.FieldParentId)
	}
	if m.FieldCleared(comment.FieldUserId) {
		fields = append(fields, comment.FieldUserId)
	}
	if m.FieldCleared(comment.FieldGuestName) {
		fields = append(fields, comment.FieldGuestName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldParentId:
		m.ClearParentId()
		return nil
	case comment.FieldUserId:
		m.ClearUserId()
		return nil
	case comment.FieldGuestName:
		m.ClearGuestName()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldTopicId:
		m.ResetTopicId()
		return nil
	case comment.FieldParentId:
		m.ResetParentId()
		return nil
	case comment.FieldUserId:
		m.ResetUserId()
		return nil
	case comment.FieldGuestName:
		m.ResetGuestName()
		return nil
	case comment.FieldMessage:
		m.ResetMessage()
		return nil
	case comment.FieldStatus:
		m.ResetStatus()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.topic != nil {
		edges = append(edges, comment.EdgeTopic)
	}
	if m.author != nil {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.parent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	if m.replies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.comment_attachments != nil {
		edges = append(edges, comment.EdgeCommentAttachments)
	}
	if m.liked_users != nil {
		edges = append(edges, comment.EdgeLikedUsers)
	}
	if m.subscribed_users != nil {
		edges = append(edges, comment.EdgeSubscribedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeCommentAttachments:
		ids := make([]ent.Value, 0, len(m.comment_attachments))
		for id := range m.comment_attachments {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.liked_users))
		for id := range m.liked_users {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.subscribed_users))
		for id := range m.subscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedreplies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.removedcomment_attachments != nil {
		edges = append(edges, comment.EdgeCommentAttachments)
	}
	if m.removedliked_users != nil {
		edges = append(edges, comment.EdgeLikedUsers)
	}
	if m.removedsubscribed_users != nil {
		edges = append(edges, comment.EdgeSubscribedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeCommentAttachments:
		ids := make([]ent.Value, 0, len(m.removedcomment_attachments))
		for id := range m.removedcomment_attachments {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.removedliked_users))
		for id := range m.removedliked_users {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_users))
		for id := range m.removedsubscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedtopic {
		edges = append(edges, comment.EdgeTopic)
	}
	if m.clearedauthor {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.clearedparent {
		edges = append(edges, comment.EdgeParent)
	}
	if m.clearedreplies {
		edges = append(edges, comment.EdgeReplies)
	}
	if m.clearedcomment_attachments {
		edges = append(edges, comment.EdgeCommentAttachments)
	}
	if m.clearedliked_users {
		edges = append(edges, comment.EdgeLikedUsers)
	}
	if m.clearedsubscribed_users {
		edges = append(edges, comment.EdgeSubscribedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeTopic:
		return m.clearedtopic
	case comment.EdgeAuthor:
		return m.clearedauthor
	case comment.EdgeParent:
		return m.clearedparent
	case comment.EdgeReplies:
		return m.clearedreplies
	case comment.EdgeCommentAttachments:
		return m.clearedcomment_attachments
	case comment.EdgeLikedUsers:
		return m.clearedliked_users
	case comment.EdgeSubscribedUsers:
		return m.clearedsubscribed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeTopic:
		m.ClearTopic()
		return nil
	case comment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case comment.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeTopic:
		m.ResetTopic()
		return nil
	case comment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case comment.EdgeParent:
		m.ResetParent()
		return nil
	case comment.EdgeReplies:
		m.ResetReplies()
		return nil
	case comment.EdgeCommentAttachments:
		m.ResetCommentAttachments()
		return nil
	case comment.EdgeLikedUsers:
		m.ResetLikedUsers()
		return nil
	case comment.EdgeSubscribedUsers:
		m.ResetSubscribedUsers()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CommentAttachmentMutation represents an operation that mutates the CommentAttachment nodes in the graph.
type CommentAttachmentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	url            *string
	_order         *int
	add_order      *int
	_type          *commentattachment.Type
	clearedFields  map[string]struct{}
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*CommentAttachment, error)
	predicates     []predicate.CommentAttachment
}

var _ ent.Mutation = (*CommentAttachmentMutation)(nil)

// commentattachmentOption allows management of the mutation configuration using functional options.
type commentattachmentOption func(*CommentAttachmentMutation)

// newCommentAttachmentMutation creates new mutation for the CommentAttachment entity.
func newCommentAttachmentMutation(c config, op Op, opts ...commentattachmentOption) *CommentAttachmentMutation {
	m := &CommentAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentAttachmentID sets the ID field of the mutation.
func withCommentAttachmentID(id int) commentattachmentOption {
	return func(m *CommentAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentAttachment
		)
		m.oldValue = func(ctx context.Context) (*CommentAttachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentAttachment sets the old CommentAttachment of the mutation.
func withCommentAttachment(node *CommentAttachment) commentattachmentOption {
	return func(m *CommentAttachmentMutation) {
		m.oldValue = func(context.Context) (*CommentAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentAttachment entities.
func (m *CommentAttachmentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentAttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentAttachmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommentAttachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommentId sets the "commentId" field.
func (m *CommentAttachmentMutation) SetCommentId(i int) {
	m.comment = &i
}

// CommentId returns the value of the "commentId" field in the mutation.
func (m *CommentAttachmentMutation) CommentId() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentId returns the old "commentId" field's value of the CommentAttachment entity.
// If the CommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentAttachmentMutation) OldCommentId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentId: %w", err)
	}
	return oldValue.CommentId, nil
}

// ResetCommentId resets all changes to the "commentId" field.
func (m *CommentAttachmentMutation) ResetCommentId() {
	m.comment = nil
}

// SetURL sets the "url" field.
func (m *CommentAttachmentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CommentAttachmentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the CommentAttachment entity.
// If the CommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentAttachmentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *CommentAttachmentMutation) ResetURL() {
	m.url = nil
}

// SetOrder sets the "order" field.
func (m *CommentAttachmentMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *CommentAttachmentMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the CommentAttachment entity.
// If the CommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentAttachmentMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *CommentAttachmentMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *CommentAttachmentMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *CommentAttachmentMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetType sets the "type" field.
func (m *CommentAttachmentMutation) SetType(c commentattachment.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CommentAttachmentMutation) GetType() (r commentattachment.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CommentAttachment entity.
// If the CommentAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentAttachmentMutation) OldType(ctx context.Context) (v commentattachment.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CommentAttachmentMutation) ResetType() {
	m._type = nil
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *CommentAttachmentMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *CommentAttachmentMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[commentattachment.FieldCommentId] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *CommentAttachmentMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *CommentAttachmentMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *CommentAttachmentMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *CommentAttachmentMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the CommentAttachmentMutation builder.
func (m *CommentAttachmentMutation) Where(ps ...predicate.CommentAttachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentAttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentAttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommentAttachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentAttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentAttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommentAttachment).
func (m *CommentAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.comment != nil {
		fields = append(fields, commentattachment.FieldCommentId)
	}
	if m.url != nil {
		fields = append(fields, commentattachment.FieldURL)
	}
	if m._order != nil {
		fields = append(fields, commentattachment.FieldOrder)
	}
	if m._type != nil {
		fields = append(fields, commentattachment.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commentattachment.FieldCommentId:
		return m.CommentId()
	case commentattachment.FieldURL:
		return m.URL()
	case commentattachment.FieldOrder:
		return m.Order()
	case commentattachment.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commentattachment.FieldCommentId:
		return m.OldCommentId(ctx)
	case commentattachment.FieldURL:
		return m.OldURL(ctx)
	case commentattachment.FieldOrder:
		return m.OldOrder(ctx)
	case commentattachment.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown CommentAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commentattachment.FieldCommentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentId(v)
		return nil
	case commentattachment.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case commentattachment.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case commentattachment.FieldType:
		v, ok := value.(commentattachment.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentAttachmentMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, commentattachment.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commentattachment.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commentattachment.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentAttachmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentAttachmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CommentAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentAttachmentMutation) ResetField(name string) error {
	switch name {
	case commentattachment.FieldCommentId:
		m.ResetCommentId()
		return nil
	case commentattachment.FieldURL:
		m.ResetURL()
		return nil
	case commentattachment.FieldOrder:
		m.ResetOrder()
		return nil
	case commentattachment.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comment != nil {
		edges = append(edges, commentattachment.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commentattachment.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentAttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomment {
		edges = append(edges, commentattachment.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case commentattachment.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case commentattachment.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case commentattachment.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown CommentAttachment edge %s", name)
}

// ForumMutation represents an operation that mutates the Forum nodes in the graph.
type ForumMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	userId                  *int
	adduserId               *int
	title                   *string
	description             *string
	thumbnailUrl            *string
	status                  *forum.Status
	createdAt               *time.Time
	updatedAt               *time.Time
	clearedFields           map[string]struct{}
	liked_users             map[int]struct{}
	removedliked_users      map[int]struct{}
	clearedliked_users      bool
	subscribed_users        map[int]struct{}
	removedsubscribed_users map[int]struct{}
	clearedsubscribed_users bool
	topics                  map[int]struct{}
	removedtopics           map[int]struct{}
	clearedtopics           bool
	done                    bool
	oldValue                func(context.Context) (*Forum, error)
	predicates              []predicate.Forum
}

var _ ent.Mutation = (*ForumMutation)(nil)

// forumOption allows management of the mutation configuration using functional options.
type forumOption func(*ForumMutation)

// newForumMutation creates new mutation for the Forum entity.
func newForumMutation(c config, op Op, opts ...forumOption) *ForumMutation {
	m := &ForumMutation{
		config:        c,
		op:            op,
		typ:           TypeForum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withForumID sets the ID field of the mutation.
func withForumID(id int) forumOption {
	return func(m *ForumMutation) {
		var (
			err   error
			once  sync.Once
			value *Forum
		)
		m.oldValue = func(ctx context.Context) (*Forum, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Forum.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withForum sets the old Forum of the mutation.
func withForum(node *Forum) forumOption {
	return func(m *ForumMutation) {
		m.oldValue = func(context.Context) (*Forum, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ForumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ForumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Forum entities.
func (m *ForumMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ForumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ForumMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Forum.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserId sets the "userId" field.
func (m *ForumMutation) SetUserId(i int) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the value of the "userId" field in the mutation.
func (m *ForumMutation) UserId() (r int, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Forum entity.
// If the Forum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForumMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to the "userId" field.
func (m *ForumMutation) AddUserId(i int) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the "userId" field in this mutation.
func (m *ForumMutation) AddedUserId() (r int, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *ForumMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetTitle sets the "title" field.
func (m *ForumMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ForumMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Forum entity.
// If the Forum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForumMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ForumMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ForumMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ForumMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Forum entity.
// If the Forum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForumMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ForumMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[forum.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ForumMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[forum.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ForumMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, forum.FieldDescription)
}

// SetThumbnailUrl sets the "thumbnailUrl" field.
func (m *ForumMutation) SetThumbnailUrl(s string) {
	m.thumbnailUrl = &s
}

// ThumbnailUrl returns the value of the "thumbnailUrl" field in the mutation.
func (m *ForumMutation) ThumbnailUrl() (r string, exists bool) {
	v := m.thumbnailUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailUrl returns the old "thumbnailUrl" field's value of the Forum entity.
// If the Forum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForumMutation) OldThumbnailUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailUrl: %w", err)
	}
	return oldValue.ThumbnailUrl, nil
}

// ClearThumbnailUrl clears the value of the "thumbnailUrl" field.
func (m *ForumMutation) ClearThumbnailUrl() {
	m.thumbnailUrl = nil
	m.clearedFields[forum.FieldThumbnailUrl] = struct{}{}
}

// ThumbnailUrlCleared returns if the "thumbnailUrl" field was cleared in this mutation.
func (m *ForumMutation) ThumbnailUrlCleared() bool {
	_, ok := m.clearedFields[forum.FieldThumbnailUrl]
	return ok
}

// ResetThumbnailUrl resets all changes to the "thumbnailUrl" field.
func (m *ForumMutation) ResetThumbnailUrl() {
	m.thumbnailUrl = nil
	delete(m.clearedFields, forum.FieldThumbnailUrl)
}

// SetStatus sets the "status" field.
func (m *ForumMutation) SetStatus(f forum.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *ForumMutation) Status() (r forum.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Forum entity.
// If the Forum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForumMutation) OldStatus(ctx context.Context) (v forum.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ForumMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *ForumMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ForumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Forum entity.
// If the Forum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ForumMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ForumMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ForumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Forum entity.
// If the Forum object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ForumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ForumMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddLikedUserIDs adds the "liked_users" edge to the User entity by ids.
func (m *ForumMutation) AddLikedUserIDs(ids ...int) {
	if m.liked_users == nil {
		m.liked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_users[ids[i]] = struct{}{}
	}
}

// ClearLikedUsers clears the "liked_users" edge to the User entity.
func (m *ForumMutation) ClearLikedUsers() {
	m.clearedliked_users = true
}

// LikedUsersCleared reports if the "liked_users" edge to the User entity was cleared.
func (m *ForumMutation) LikedUsersCleared() bool {
	return m.clearedliked_users
}

// RemoveLikedUserIDs removes the "liked_users" edge to the User entity by IDs.
func (m *ForumMutation) RemoveLikedUserIDs(ids ...int) {
	if m.removedliked_users == nil {
		m.removedliked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_users, ids[i])
		m.removedliked_users[ids[i]] = struct{}{}
	}
}

// RemovedLikedUsers returns the removed IDs of the "liked_users" edge to the User entity.
func (m *ForumMutation) RemovedLikedUsersIDs() (ids []int) {
	for id := range m.removedliked_users {
		ids = append(ids, id)
	}
	return
}

// LikedUsersIDs returns the "liked_users" edge IDs in the mutation.
func (m *ForumMutation) LikedUsersIDs() (ids []int) {
	for id := range m.liked_users {
		ids = append(ids, id)
	}
	return
}

// ResetLikedUsers resets all changes to the "liked_users" edge.
func (m *ForumMutation) ResetLikedUsers() {
	m.liked_users = nil
	m.clearedliked_users = false
	m.removedliked_users = nil
}

// AddSubscribedUserIDs adds the "subscribed_users" edge to the User entity by ids.
func (m *ForumMutation) AddSubscribedUserIDs(ids ...int) {
	if m.subscribed_users == nil {
		m.subscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_users[ids[i]] = struct{}{}
	}
}

// ClearSubscribedUsers clears the "subscribed_users" edge to the User entity.
func (m *ForumMutation) ClearSubscribedUsers() {
	m.clearedsubscribed_users = true
}

// SubscribedUsersCleared reports if the "subscribed_users" edge to the User entity was cleared.
func (m *ForumMutation) SubscribedUsersCleared() bool {
	return m.clearedsubscribed_users
}

// RemoveSubscribedUserIDs removes the "subscribed_users" edge to the User entity by IDs.
func (m *ForumMutation) RemoveSubscribedUserIDs(ids ...int) {
	if m.removedsubscribed_users == nil {
		m.removedsubscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_users, ids[i])
		m.removedsubscribed_users[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedUsers returns the removed IDs of the "subscribed_users" edge to the User entity.
func (m *ForumMutation) RemovedSubscribedUsersIDs() (ids []int) {
	for id := range m.removedsubscribed_users {
		ids = append(ids, id)
	}
	return
}

// SubscribedUsersIDs returns the "subscribed_users" edge IDs in the mutation.
func (m *ForumMutation) SubscribedUsersIDs() (ids []int) {
	for id := range m.subscribed_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedUsers resets all changes to the "subscribed_users" edge.
func (m *ForumMutation) ResetSubscribedUsers() {
	m.subscribed_users = nil
	m.clearedsubscribed_users = false
	m.removedsubscribed_users = nil
}

// AddTopicIDs adds the "topics" edge to the Topic entity by ids.
func (m *ForumMutation) AddTopicIDs(ids ...int) {
	if m.topics == nil {
		m.topics = make(map[int]struct{})
	}
	for i := range ids {
		m.topics[ids[i]] = struct{}{}
	}
}

// ClearTopics clears the "topics" edge to the Topic entity.
func (m *ForumMutation) ClearTopics() {
	m.clearedtopics = true
}

// TopicsCleared reports if the "topics" edge to the Topic entity was cleared.
func (m *ForumMutation) TopicsCleared() bool {
	return m.clearedtopics
}

// RemoveTopicIDs removes the "topics" edge to the Topic entity by IDs.
func (m *ForumMutation) RemoveTopicIDs(ids ...int) {
	if m.removedtopics == nil {
		m.removedtopics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.topics, ids[i])
		m.removedtopics[ids[i]] = struct{}{}
	}
}

// RemovedTopics returns the removed IDs of the "topics" edge to the Topic entity.
func (m *ForumMutation) RemovedTopicsIDs() (ids []int) {
	for id := range m.removedtopics {
		ids = append(ids, id)
	}
	return
}

// TopicsIDs returns the "topics" edge IDs in the mutation.
func (m *ForumMutation) TopicsIDs() (ids []int) {
	for id := range m.topics {
		ids = append(ids, id)
	}
	return
}

// ResetTopics resets all changes to the "topics" edge.
func (m *ForumMutation) ResetTopics() {
	m.topics = nil
	m.clearedtopics = false
	m.removedtopics = nil
}

// Where appends a list predicates to the ForumMutation builder.
func (m *ForumMutation) Where(ps ...predicate.Forum) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ForumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ForumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Forum, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ForumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ForumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Forum).
func (m *ForumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ForumMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.userId != nil {
		fields = append(fields, forum.FieldUserId)
	}
	if m.title != nil {
		fields = append(fields, forum.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, forum.FieldDescription)
	}
	if m.thumbnailUrl != nil {
		fields = append(fields, forum.FieldThumbnailUrl)
	}
	if m.status != nil {
		fields = append(fields, forum.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, forum.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, forum.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ForumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case forum.FieldUserId:
		return m.UserId()
	case forum.FieldTitle:
		return m.Title()
	case forum.FieldDescription:
		return m.Description()
	case forum.FieldThumbnailUrl:
		return m.ThumbnailUrl()
	case forum.FieldStatus:
		return m.Status()
	case forum.FieldCreatedAt:
		return m.CreatedAt()
	case forum.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ForumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case forum.FieldUserId:
		return m.OldUserId(ctx)
	case forum.FieldTitle:
		return m.OldTitle(ctx)
	case forum.FieldDescription:
		return m.OldDescription(ctx)
	case forum.FieldThumbnailUrl:
		return m.OldThumbnailUrl(ctx)
	case forum.FieldStatus:
		return m.OldStatus(ctx)
	case forum.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case forum.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Forum field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ForumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case forum.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case forum.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case forum.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case forum.FieldThumbnailUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailUrl(v)
		return nil
	case forum.FieldStatus:
		v, ok := value.(forum.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case forum.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case forum.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Forum field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ForumMutation) AddedFields() []string {
	var fields []string
	if m.adduserId != nil {
		fields = append(fields, forum.FieldUserId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ForumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case forum.FieldUserId:
		return m.AddedUserId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ForumMutation) AddField(name string, value ent.Value) error {
	switch name {
	case forum.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	}
	return fmt.Errorf("unknown Forum numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ForumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(forum.FieldDescription) {
		fields = append(fields, forum.FieldDescription)
	}
	if m.FieldCleared(forum.FieldThumbnailUrl) {
		fields = append(fields, forum.FieldThumbnailUrl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ForumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ForumMutation) ClearField(name string) error {
	switch name {
	case forum.FieldDescription:
		m.ClearDescription()
		return nil
	case forum.FieldThumbnailUrl:
		m.ClearThumbnailUrl()
		return nil
	}
	return fmt.Errorf("unknown Forum nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ForumMutation) ResetField(name string) error {
	switch name {
	case forum.FieldUserId:
		m.ResetUserId()
		return nil
	case forum.FieldTitle:
		m.ResetTitle()
		return nil
	case forum.FieldDescription:
		m.ResetDescription()
		return nil
	case forum.FieldThumbnailUrl:
		m.ResetThumbnailUrl()
		return nil
	case forum.FieldStatus:
		m.ResetStatus()
		return nil
	case forum.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case forum.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Forum field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ForumMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.liked_users != nil {
		edges = append(edges, forum.EdgeLikedUsers)
	}
	if m.subscribed_users != nil {
		edges = append(edges, forum.EdgeSubscribedUsers)
	}
	if m.topics != nil {
		edges = append(edges, forum.EdgeTopics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ForumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case forum.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.liked_users))
		for id := range m.liked_users {
			ids = append(ids, id)
		}
		return ids
	case forum.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.subscribed_users))
		for id := range m.subscribed_users {
			ids = append(ids, id)
		}
		return ids
	case forum.EdgeTopics:
		ids := make([]ent.Value, 0, len(m.topics))
		for id := range m.topics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ForumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedliked_users != nil {
		edges = append(edges, forum.EdgeLikedUsers)
	}
	if m.removedsubscribed_users != nil {
		edges = append(edges, forum.EdgeSubscribedUsers)
	}
	if m.removedtopics != nil {
		edges = append(edges, forum.EdgeTopics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ForumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case forum.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.removedliked_users))
		for id := range m.removedliked_users {
			ids = append(ids, id)
		}
		return ids
	case forum.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_users))
		for id := range m.removedsubscribed_users {
			ids = append(ids, id)
		}
		return ids
	case forum.EdgeTopics:
		ids := make([]ent.Value, 0, len(m.removedtopics))
		for id := range m.removedtopics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ForumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedliked_users {
		edges = append(edges, forum.EdgeLikedUsers)
	}
	if m.clearedsubscribed_users {
		edges = append(edges, forum.EdgeSubscribedUsers)
	}
	if m.clearedtopics {
		edges = append(edges, forum.EdgeTopics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ForumMutation) EdgeCleared(name string) bool {
	switch name {
	case forum.EdgeLikedUsers:
		return m.clearedliked_users
	case forum.EdgeSubscribedUsers:
		return m.clearedsubscribed_users
	case forum.EdgeTopics:
		return m.clearedtopics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ForumMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Forum unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ForumMutation) ResetEdge(name string) error {
	switch name {
	case forum.EdgeLikedUsers:
		m.ResetLikedUsers()
		return nil
	case forum.EdgeSubscribedUsers:
		m.ResetSubscribedUsers()
		return nil
	case forum.EdgeTopics:
		m.ResetTopics()
		return nil
	}
	return fmt.Errorf("unknown Forum edge %s", name)
}

// TopicMutation represents an operation that mutates the Topic nodes in the graph.
type TopicMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	title                   *string
	description             *string
	thumbnailUrl            *string
	isAutoGenerated         *bool
	isNotifyOnComment       *bool
	status                  *topic.Status
	createdAt               *time.Time
	updatedAt               *time.Time
	clearedFields           map[string]struct{}
	forum                   *int
	clearedforum            bool
	owner                   *int
	clearedowner            bool
	comments                map[int]struct{}
	removedcomments         map[int]struct{}
	clearedcomments         bool
	tags                    map[int]struct{}
	removedtags             map[int]struct{}
	clearedtags             bool
	liked_users             map[int]struct{}
	removedliked_users      map[int]struct{}
	clearedliked_users      bool
	subscribed_users        map[int]struct{}
	removedsubscribed_users map[int]struct{}
	clearedsubscribed_users bool
	done                    bool
	oldValue                func(context.Context) (*Topic, error)
	predicates              []predicate.Topic
}

var _ ent.Mutation = (*TopicMutation)(nil)

// topicOption allows management of the mutation configuration using functional options.
type topicOption func(*TopicMutation)

// newTopicMutation creates new mutation for the Topic entity.
func newTopicMutation(c config, op Op, opts ...topicOption) *TopicMutation {
	m := &TopicMutation{
		config:        c,
		op:            op,
		typ:           TypeTopic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopicID sets the ID field of the mutation.
func withTopicID(id int) topicOption {
	return func(m *TopicMutation) {
		var (
			err   error
			once  sync.Once
			value *Topic
		)
		m.oldValue = func(ctx context.Context) (*Topic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Topic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopic sets the old Topic of the mutation.
func withTopic(node *Topic) topicOption {
	return func(m *TopicMutation) {
		m.oldValue = func(context.Context) (*Topic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Topic entities.
func (m *TopicMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Topic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetForumId sets the "forumId" field.
func (m *TopicMutation) SetForumId(i int) {
	m.forum = &i
}

// ForumId returns the value of the "forumId" field in the mutation.
func (m *TopicMutation) ForumId() (r int, exists bool) {
	v := m.forum
	if v == nil {
		return
	}
	return *v, true
}

// OldForumId returns the old "forumId" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldForumId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForumId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForumId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForumId: %w", err)
	}
	return oldValue.ForumId, nil
}

// ResetForumId resets all changes to the "forumId" field.
func (m *TopicMutation) ResetForumId() {
	m.forum = nil
}

// SetUserId sets the "userId" field.
func (m *TopicMutation) SetUserId(i int) {
	m.owner = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *TopicMutation) UserId() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ResetUserId resets all changes to the "userId" field.
func (m *TopicMutation) ResetUserId() {
	m.owner = nil
}

// SetTitle sets the "title" field.
func (m *TopicMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TopicMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *TopicMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[topic.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *TopicMutation) TitleCleared() bool {
	_, ok := m.clearedFields[topic.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *TopicMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, topic.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *TopicMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TopicMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TopicMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[topic.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TopicMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[topic.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TopicMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, topic.FieldDescription)
}

// SetThumbnailUrl sets the "thumbnailUrl" field.
func (m *TopicMutation) SetThumbnailUrl(s string) {
	m.thumbnailUrl = &s
}

// ThumbnailUrl returns the value of the "thumbnailUrl" field in the mutation.
func (m *TopicMutation) ThumbnailUrl() (r string, exists bool) {
	v := m.thumbnailUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailUrl returns the old "thumbnailUrl" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldThumbnailUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailUrl: %w", err)
	}
	return oldValue.ThumbnailUrl, nil
}

// ClearThumbnailUrl clears the value of the "thumbnailUrl" field.
func (m *TopicMutation) ClearThumbnailUrl() {
	m.thumbnailUrl = nil
	m.clearedFields[topic.FieldThumbnailUrl] = struct{}{}
}

// ThumbnailUrlCleared returns if the "thumbnailUrl" field was cleared in this mutation.
func (m *TopicMutation) ThumbnailUrlCleared() bool {
	_, ok := m.clearedFields[topic.FieldThumbnailUrl]
	return ok
}

// ResetThumbnailUrl resets all changes to the "thumbnailUrl" field.
func (m *TopicMutation) ResetThumbnailUrl() {
	m.thumbnailUrl = nil
	delete(m.clearedFields, topic.FieldThumbnailUrl)
}

// SetIsAutoGenerated sets the "isAutoGenerated" field.
func (m *TopicMutation) SetIsAutoGenerated(b bool) {
	m.isAutoGenerated = &b
}

// IsAutoGenerated returns the value of the "isAutoGenerated" field in the mutation.
func (m *TopicMutation) IsAutoGenerated() (r bool, exists bool) {
	v := m.isAutoGenerated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoGenerated returns the old "isAutoGenerated" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldIsAutoGenerated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutoGenerated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutoGenerated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoGenerated: %w", err)
	}
	return oldValue.IsAutoGenerated, nil
}

// ResetIsAutoGenerated resets all changes to the "isAutoGenerated" field.
func (m *TopicMutation) ResetIsAutoGenerated() {
	m.isAutoGenerated = nil
}

// SetIsNotifyOnComment sets the "isNotifyOnComment" field.
func (m *TopicMutation) SetIsNotifyOnComment(b bool) {
	m.isNotifyOnComment = &b
}

// IsNotifyOnComment returns the value of the "isNotifyOnComment" field in the mutation.
func (m *TopicMutation) IsNotifyOnComment() (r bool, exists bool) {
	v := m.isNotifyOnComment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNotifyOnComment returns the old "isNotifyOnComment" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldIsNotifyOnComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNotifyOnComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNotifyOnComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNotifyOnComment: %w", err)
	}
	return oldValue.IsNotifyOnComment, nil
}

// ResetIsNotifyOnComment resets all changes to the "isNotifyOnComment" field.
func (m *TopicMutation) ResetIsNotifyOnComment() {
	m.isNotifyOnComment = nil
}

// SetStatus sets the "status" field.
func (m *TopicMutation) SetStatus(t topic.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TopicMutation) Status() (r topic.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldStatus(ctx context.Context) (v topic.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TopicMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *TopicMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TopicMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TopicMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *TopicMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *TopicMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *TopicMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetForumID sets the "forum" edge to the Forum entity by id.
func (m *TopicMutation) SetForumID(id int) {
	m.forum = &id
}

// ClearForum clears the "forum" edge to the Forum entity.
func (m *TopicMutation) ClearForum() {
	m.clearedforum = true
	m.clearedFields[topic.FieldForumId] = struct{}{}
}

// ForumCleared reports if the "forum" edge to the Forum entity was cleared.
func (m *TopicMutation) ForumCleared() bool {
	return m.clearedforum
}

// ForumID returns the "forum" edge ID in the mutation.
func (m *TopicMutation) ForumID() (id int, exists bool) {
	if m.forum != nil {
		return *m.forum, true
	}
	return
}

// ForumIDs returns the "forum" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ForumID instead. It exists only for internal usage by the builders.
func (m *TopicMutation) ForumIDs() (ids []int) {
	if id := m.forum; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetForum resets all changes to the "forum" edge.
func (m *TopicMutation) ResetForum() {
	m.forum = nil
	m.clearedforum = false
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TopicMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TopicMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[topic.FieldUserId] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TopicMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TopicMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TopicMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TopicMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *TopicMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *TopicMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *TopicMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *TopicMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *TopicMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *TopicMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *TopicMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddTagIDs adds the "tags" edge to the TopicTag entity by ids.
func (m *TopicMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the TopicTag entity.
func (m *TopicMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the TopicTag entity was cleared.
func (m *TopicMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the TopicTag entity by IDs.
func (m *TopicMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the TopicTag entity.
func (m *TopicMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TopicMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TopicMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddLikedUserIDs adds the "liked_users" edge to the User entity by ids.
func (m *TopicMutation) AddLikedUserIDs(ids ...int) {
	if m.liked_users == nil {
		m.liked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_users[ids[i]] = struct{}{}
	}
}

// ClearLikedUsers clears the "liked_users" edge to the User entity.
func (m *TopicMutation) ClearLikedUsers() {
	m.clearedliked_users = true
}

// LikedUsersCleared reports if the "liked_users" edge to the User entity was cleared.
func (m *TopicMutation) LikedUsersCleared() bool {
	return m.clearedliked_users
}

// RemoveLikedUserIDs removes the "liked_users" edge to the User entity by IDs.
func (m *TopicMutation) RemoveLikedUserIDs(ids ...int) {
	if m.removedliked_users == nil {
		m.removedliked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_users, ids[i])
		m.removedliked_users[ids[i]] = struct{}{}
	}
}

// RemovedLikedUsers returns the removed IDs of the "liked_users" edge to the User entity.
func (m *TopicMutation) RemovedLikedUsersIDs() (ids []int) {
	for id := range m.removedliked_users {
		ids = append(ids, id)
	}
	return
}

// LikedUsersIDs returns the "liked_users" edge IDs in the mutation.
func (m *TopicMutation) LikedUsersIDs() (ids []int) {
	for id := range m.liked_users {
		ids = append(ids, id)
	}
	return
}

// ResetLikedUsers resets all changes to the "liked_users" edge.
func (m *TopicMutation) ResetLikedUsers() {
	m.liked_users = nil
	m.clearedliked_users = false
	m.removedliked_users = nil
}

// AddSubscribedUserIDs adds the "subscribed_users" edge to the User entity by ids.
func (m *TopicMutation) AddSubscribedUserIDs(ids ...int) {
	if m.subscribed_users == nil {
		m.subscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_users[ids[i]] = struct{}{}
	}
}

// ClearSubscribedUsers clears the "subscribed_users" edge to the User entity.
func (m *TopicMutation) ClearSubscribedUsers() {
	m.clearedsubscribed_users = true
}

// SubscribedUsersCleared reports if the "subscribed_users" edge to the User entity was cleared.
func (m *TopicMutation) SubscribedUsersCleared() bool {
	return m.clearedsubscribed_users
}

// RemoveSubscribedUserIDs removes the "subscribed_users" edge to the User entity by IDs.
func (m *TopicMutation) RemoveSubscribedUserIDs(ids ...int) {
	if m.removedsubscribed_users == nil {
		m.removedsubscribed_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_users, ids[i])
		m.removedsubscribed_users[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedUsers returns the removed IDs of the "subscribed_users" edge to the User entity.
func (m *TopicMutation) RemovedSubscribedUsersIDs() (ids []int) {
	for id := range m.removedsubscribed_users {
		ids = append(ids, id)
	}
	return
}

// SubscribedUsersIDs returns the "subscribed_users" edge IDs in the mutation.
func (m *TopicMutation) SubscribedUsersIDs() (ids []int) {
	for id := range m.subscribed_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedUsers resets all changes to the "subscribed_users" edge.
func (m *TopicMutation) ResetSubscribedUsers() {
	m.subscribed_users = nil
	m.clearedsubscribed_users = false
	m.removedsubscribed_users = nil
}

// Where appends a list predicates to the TopicMutation builder.
func (m *TopicMutation) Where(ps ...predicate.Topic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Topic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Topic).
func (m *TopicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopicMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.forum != nil {
		fields = append(fields, topic.FieldForumId)
	}
	if m.owner != nil {
		fields = append(fields, topic.FieldUserId)
	}
	if m.title != nil {
		fields = append(fields, topic.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, topic.FieldDescription)
	}
	if m.thumbnailUrl != nil {
		fields = append(fields, topic.FieldThumbnailUrl)
	}
	if m.isAutoGenerated != nil {
		fields = append(fields, topic.FieldIsAutoGenerated)
	}
	if m.isNotifyOnComment != nil {
		fields = append(fields, topic.FieldIsNotifyOnComment)
	}
	if m.status != nil {
		fields = append(fields, topic.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, topic.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, topic.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topic.FieldForumId:
		return m.ForumId()
	case topic.FieldUserId:
		return m.UserId()
	case topic.FieldTitle:
		return m.Title()
	case topic.FieldDescription:
		return m.Description()
	case topic.FieldThumbnailUrl:
		return m.ThumbnailUrl()
	case topic.FieldIsAutoGenerated:
		return m.IsAutoGenerated()
	case topic.FieldIsNotifyOnComment:
		return m.IsNotifyOnComment()
	case topic.FieldStatus:
		return m.Status()
	case topic.FieldCreatedAt:
		return m.CreatedAt()
	case topic.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topic.FieldForumId:
		return m.OldForumId(ctx)
	case topic.FieldUserId:
		return m.OldUserId(ctx)
	case topic.FieldTitle:
		return m.OldTitle(ctx)
	case topic.FieldDescription:
		return m.OldDescription(ctx)
	case topic.FieldThumbnailUrl:
		return m.OldThumbnailUrl(ctx)
	case topic.FieldIsAutoGenerated:
		return m.OldIsAutoGenerated(ctx)
	case topic.FieldIsNotifyOnComment:
		return m.OldIsNotifyOnComment(ctx)
	case topic.FieldStatus:
		return m.OldStatus(ctx)
	case topic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case topic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Topic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topic.FieldForumId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForumId(v)
		return nil
	case topic.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case topic.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case topic.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case topic.FieldThumbnailUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailUrl(v)
		return nil
	case topic.FieldIsAutoGenerated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoGenerated(v)
		return nil
	case topic.FieldIsNotifyOnComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotifyOnComment(v)
		return nil
	case topic.FieldStatus:
		v, ok := value.(topic.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case topic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case topic.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopicMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topic.FieldTitle) {
		fields = append(fields, topic.FieldTitle)
	}
	if m.FieldCleared(topic.FieldDescription) {
		fields = append(fields, topic.FieldDescription)
	}
	if m.FieldCleared(topic.FieldThumbnailUrl) {
		fields = append(fields, topic.FieldThumbnailUrl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopicMutation) ClearField(name string) error {
	switch name {
	case topic.FieldTitle:
		m.ClearTitle()
		return nil
	case topic.FieldDescription:
		m.ClearDescription()
		return nil
	case topic.FieldThumbnailUrl:
		m.ClearThumbnailUrl()
		return nil
	}
	return fmt.Errorf("unknown Topic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopicMutation) ResetField(name string) error {
	switch name {
	case topic.FieldForumId:
		m.ResetForumId()
		return nil
	case topic.FieldUserId:
		m.ResetUserId()
		return nil
	case topic.FieldTitle:
		m.ResetTitle()
		return nil
	case topic.FieldDescription:
		m.ResetDescription()
		return nil
	case topic.FieldThumbnailUrl:
		m.ResetThumbnailUrl()
		return nil
	case topic.FieldIsAutoGenerated:
		m.ResetIsAutoGenerated()
		return nil
	case topic.FieldIsNotifyOnComment:
		m.ResetIsNotifyOnComment()
		return nil
	case topic.FieldStatus:
		m.ResetStatus()
		return nil
	case topic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case topic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopicMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.forum != nil {
		edges = append(edges, topic.EdgeForum)
	}
	if m.owner != nil {
		edges = append(edges, topic.EdgeOwner)
	}
	if m.comments != nil {
		edges = append(edges, topic.EdgeComments)
	}
	if m.tags != nil {
		edges = append(edges, topic.EdgeTags)
	}
	if m.liked_users != nil {
		edges = append(edges, topic.EdgeLikedUsers)
	}
	if m.subscribed_users != nil {
		edges = append(edges, topic.EdgeSubscribedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeForum:
		if id := m.forum; id != nil {
			return []ent.Value{*id}
		}
	case topic.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case topic.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.liked_users))
		for id := range m.liked_users {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.subscribed_users))
		for id := range m.subscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcomments != nil {
		edges = append(edges, topic.EdgeComments)
	}
	if m.removedtags != nil {
		edges = append(edges, topic.EdgeTags)
	}
	if m.removedliked_users != nil {
		edges = append(edges, topic.EdgeLikedUsers)
	}
	if m.removedsubscribed_users != nil {
		edges = append(edges, topic.EdgeSubscribedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeLikedUsers:
		ids := make([]ent.Value, 0, len(m.removedliked_users))
		for id := range m.removedliked_users {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeSubscribedUsers:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_users))
		for id := range m.removedsubscribed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedforum {
		edges = append(edges, topic.EdgeForum)
	}
	if m.clearedowner {
		edges = append(edges, topic.EdgeOwner)
	}
	if m.clearedcomments {
		edges = append(edges, topic.EdgeComments)
	}
	if m.clearedtags {
		edges = append(edges, topic.EdgeTags)
	}
	if m.clearedliked_users {
		edges = append(edges, topic.EdgeLikedUsers)
	}
	if m.clearedsubscribed_users {
		edges = append(edges, topic.EdgeSubscribedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopicMutation) EdgeCleared(name string) bool {
	switch name {
	case topic.EdgeForum:
		return m.clearedforum
	case topic.EdgeOwner:
		return m.clearedowner
	case topic.EdgeComments:
		return m.clearedcomments
	case topic.EdgeTags:
		return m.clearedtags
	case topic.EdgeLikedUsers:
		return m.clearedliked_users
	case topic.EdgeSubscribedUsers:
		return m.clearedsubscribed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopicMutation) ClearEdge(name string) error {
	switch name {
	case topic.EdgeForum:
		m.ClearForum()
		return nil
	case topic.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Topic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopicMutation) ResetEdge(name string) error {
	switch name {
	case topic.EdgeForum:
		m.ResetForum()
		return nil
	case topic.EdgeOwner:
		m.ResetOwner()
		return nil
	case topic.EdgeComments:
		m.ResetComments()
		return nil
	case topic.EdgeTags:
		m.ResetTags()
		return nil
	case topic.EdgeLikedUsers:
		m.ResetLikedUsers()
		return nil
	case topic.EdgeSubscribedUsers:
		m.ResetSubscribedUsers()
		return nil
	}
	return fmt.Errorf("unknown Topic edge %s", name)
}

// TopicTagMutation represents an operation that mutates the TopicTag nodes in the graph.
type TopicTagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	createdAt     *time.Time
	clearedFields map[string]struct{}
	topics        map[int]struct{}
	removedtopics map[int]struct{}
	clearedtopics bool
	done          bool
	oldValue      func(context.Context) (*TopicTag, error)
	predicates    []predicate.TopicTag
}

var _ ent.Mutation = (*TopicTagMutation)(nil)

// topictagOption allows management of the mutation configuration using functional options.
type topictagOption func(*TopicTagMutation)

// newTopicTagMutation creates new mutation for the TopicTag entity.
func newTopicTagMutation(c config, op Op, opts ...topictagOption) *TopicTagMutation {
	m := &TopicTagMutation{
		config:        c,
		op:            op,
		typ:           TypeTopicTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopicTagID sets the ID field of the mutation.
func withTopicTagID(id int) topictagOption {
	return func(m *TopicTagMutation) {
		var (
			err   error
			once  sync.Once
			value *TopicTag
		)
		m.oldValue = func(ctx context.Context) (*TopicTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TopicTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopicTag sets the old TopicTag of the mutation.
func withTopicTag(node *TopicTag) topictagOption {
	return func(m *TopicTagMutation) {
		m.oldValue = func(context.Context) (*TopicTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopicTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopicTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TopicTag entities.
func (m *TopicTagMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopicTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopicTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TopicTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TopicTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TopicTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TopicTag entity.
// If the TopicTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TopicTagMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *TopicTagMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TopicTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the TopicTag entity.
// If the TopicTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TopicTagMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// AddTopicIDs adds the "topics" edge to the Topic entity by ids.
func (m *TopicTagMutation) AddTopicIDs(ids ...int) {
	if m.topics == nil {
		m.topics = make(map[int]struct{})
	}
	for i := range ids {
		m.topics[ids[i]] = struct{}{}
	}
}

// ClearTopics clears the "topics" edge to the Topic entity.
func (m *TopicTagMutation) ClearTopics() {
	m.clearedtopics = true
}

// TopicsCleared reports if the "topics" edge to the Topic entity was cleared.
func (m *TopicTagMutation) TopicsCleared() bool {
	return m.clearedtopics
}

// RemoveTopicIDs removes the "topics" edge to the Topic entity by IDs.
func (m *TopicTagMutation) RemoveTopicIDs(ids ...int) {
	if m.removedtopics == nil {
		m.removedtopics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.topics, ids[i])
		m.removedtopics[ids[i]] = struct{}{}
	}
}

// RemovedTopics returns the removed IDs of the "topics" edge to the Topic entity.
func (m *TopicTagMutation) RemovedTopicsIDs() (ids []int) {
	for id := range m.removedtopics {
		ids = append(ids, id)
	}
	return
}

// TopicsIDs returns the "topics" edge IDs in the mutation.
func (m *TopicTagMutation) TopicsIDs() (ids []int) {
	for id := range m.topics {
		ids = append(ids, id)
	}
	return
}

// ResetTopics resets all changes to the "topics" edge.
func (m *TopicTagMutation) ResetTopics() {
	m.topics = nil
	m.clearedtopics = false
	m.removedtopics = nil
}

// Where appends a list predicates to the TopicTagMutation builder.
func (m *TopicTagMutation) Where(ps ...predicate.TopicTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopicTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopicTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TopicTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopicTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopicTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TopicTag).
func (m *TopicTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopicTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, topictag.FieldName)
	}
	if m.createdAt != nil {
		fields = append(fields, topictag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopicTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topictag.FieldName:
		return m.Name()
	case topictag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopicTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topictag.FieldName:
		return m.OldName(ctx)
	case topictag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TopicTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topictag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case topictag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TopicTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopicTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopicTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TopicTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopicTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopicTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopicTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TopicTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopicTagMutation) ResetField(name string) error {
	switch name {
	case topictag.FieldName:
		m.ResetName()
		return nil
	case topictag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown TopicTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopicTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.topics != nil {
		edges = append(edges, topictag.EdgeTopics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopicTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case topictag.EdgeTopics:
		ids := make([]ent.Value, 0, len(m.topics))
		for id := range m.topics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopicTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtopics != nil {
		edges = append(edges, topictag.EdgeTopics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopicTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case topictag.EdgeTopics:
		ids := make([]ent.Value, 0, len(m.removedtopics))
		for id := range m.removedtopics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopicTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtopics {
		edges = append(edges, topictag.EdgeTopics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopicTagMutation) EdgeCleared(name string) bool {
	switch name {
	case topictag.EdgeTopics:
		return m.clearedtopics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopicTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TopicTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopicTagMutation) ResetEdge(name string) error {
	switch name {
	case topictag.EdgeTopics:
		m.ResetTopics()
		return nil
	}
	return fmt.Errorf("unknown TopicTag edge %s", name)
}

// TopicTaggingMutation represents an operation that mutates the TopicTagging nodes in the graph.
type TopicTaggingMutation struct {
	config
	op            Op
	typ           string
	clearedFields map[string]struct{}
	topic         *int
	clearedtopic  bool
	tag           *int
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*TopicTagging, error)
	predicates    []predicate.TopicTagging
}

var _ ent.Mutation = (*TopicTaggingMutation)(nil)

// topictaggingOption allows management of the mutation configuration using functional options.
type topictaggingOption func(*TopicTaggingMutation)

// newTopicTaggingMutation creates new mutation for the TopicTagging entity.
func newTopicTaggingMutation(c config, op Op, opts ...topictaggingOption) *TopicTaggingMutation {
	m := &TopicTaggingMutation{
		config:        c,
		op:            op,
		typ:           TypeTopicTagging,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopicTaggingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopicTaggingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetTopicId sets the "topicId" field.
func (m *TopicTaggingMutation) SetTopicId(i int) {
	m.topic = &i
}

// TopicId returns the value of the "topicId" field in the mutation.
func (m *TopicTaggingMutation) TopicId() (r int, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// ResetTopicId resets all changes to the "topicId" field.
func (m *TopicTaggingMutation) ResetTopicId() {
	m.topic = nil
}

// SetTagId sets the "tagId" field.
func (m *TopicTaggingMutation) SetTagId(i int) {
	m.tag = &i
}

// TagId returns the value of the "tagId" field in the mutation.
func (m *TopicTaggingMutation) TagId() (r int, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagId resets all changes to the "tagId" field.
func (m *TopicTaggingMutation) ResetTagId() {
	m.tag = nil
}

// SetTopicID sets the "topic" edge to the Topic entity by id.
func (m *TopicTaggingMutation) SetTopicID(id int) {
	m.topic = &id
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *TopicTaggingMutation) ClearTopic() {
	m.clearedtopic = true
	m.clearedFields[topictagging.FieldTopicId] = struct{}{}
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *TopicTaggingMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicID returns the "topic" edge ID in the mutation.
func (m *TopicTaggingMutation) TopicID() (id int, exists bool) {
	if m.topic != nil {
		return *m.topic, true
	}
	return
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *TopicTaggingMutation) TopicIDs() (ids []int) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *TopicTaggingMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// SetTagID sets the "tag" edge to the TopicTag entity by id.
func (m *TopicTaggingMutation) SetTagID(id int) {
	m.tag = &id
}

// ClearTag clears the "tag" edge to the TopicTag entity.
func (m *TopicTaggingMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[topictagging.FieldTagId] = struct{}{}
}

// TagCleared reports if the "tag" edge to the TopicTag entity was cleared.
func (m *TopicTaggingMutation) TagCleared() bool {
	return m.clearedtag
}

// TagID returns the "tag" edge ID in the mutation.
func (m *TopicTaggingMutation) TagID() (id int, exists bool) {
	if m.tag != nil {
		return *m.tag, true
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *TopicTaggingMutation) TagIDs() (ids []int) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *TopicTaggingMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the TopicTaggingMutation builder.
func (m *TopicTaggingMutation) Where(ps ...predicate.TopicTagging) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopicTaggingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopicTaggingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TopicTagging, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopicTaggingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopicTaggingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TopicTagging).
func (m *TopicTaggingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopicTaggingMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.topic != nil {
		fields = append(fields, topictagging.FieldTopicId)
	}
	if m.tag != nil {
		fields = append(fields, topictagging.FieldTagId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopicTaggingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topictagging.FieldTopicId:
		return m.TopicId()
	case topictagging.FieldTagId:
		return m.TagId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopicTaggingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema TopicTagging does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicTaggingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topictagging.FieldTopicId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicId(v)
		return nil
	case topictagging.FieldTagId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagId(v)
		return nil
	}
	return fmt.Errorf("unknown TopicTagging field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopicTaggingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopicTaggingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicTaggingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TopicTagging numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopicTaggingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopicTaggingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopicTaggingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TopicTagging nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopicTaggingMutation) ResetField(name string) error {
	switch name {
	case topictagging.FieldTopicId:
		m.ResetTopicId()
		return nil
	case topictagging.FieldTagId:
		m.ResetTagId()
		return nil
	}
	return fmt.Errorf("unknown TopicTagging field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopicTaggingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.topic != nil {
		edges = append(edges, topictagging.EdgeTopic)
	}
	if m.tag != nil {
		edges = append(edges, topictagging.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopicTaggingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case topictagging.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	case topictagging.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopicTaggingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopicTaggingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopicTaggingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtopic {
		edges = append(edges, topictagging.EdgeTopic)
	}
	if m.clearedtag {
		edges = append(edges, topictagging.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopicTaggingMutation) EdgeCleared(name string) bool {
	switch name {
	case topictagging.EdgeTopic:
		return m.clearedtopic
	case topictagging.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopicTaggingMutation) ClearEdge(name string) error {
	switch name {
	case topictagging.EdgeTopic:
		m.ClearTopic()
		return nil
	case topictagging.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown TopicTagging unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopicTaggingMutation) ResetEdge(name string) error {
	switch name {
	case topictagging.EdgeTopic:
		m.ResetTopic()
		return nil
	case topictagging.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown TopicTagging edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	userName                   *string
	email                      *string
	password                   *string
	displayName                *string
	avatarUrl                  *string
	status                     *user.Status
	createdAt                  *time.Time
	updatedAt                  *time.Time
	clearedFields              map[string]struct{}
	forums                     map[int]struct{}
	removedforums              map[int]struct{}
	clearedforums              bool
	topics                     map[int]struct{}
	removedtopics              map[int]struct{}
	clearedtopics              bool
	comments                   map[int]struct{}
	removedcomments            map[int]struct{}
	clearedcomments            bool
	liked_forums               map[int]struct{}
	removedliked_forums        map[int]struct{}
	clearedliked_forums        bool
	liked_topics               map[int]struct{}
	removedliked_topics        map[int]struct{}
	clearedliked_topics        bool
	liked_comments             map[int]struct{}
	removedliked_comments      map[int]struct{}
	clearedliked_comments      bool
	subscribed_forums          map[int]struct{}
	removedsubscribed_forums   map[int]struct{}
	clearedsubscribed_forums   bool
	subscribed_topics          map[int]struct{}
	removedsubscribed_topics   map[int]struct{}
	clearedsubscribed_topics   bool
	subscribed_comments        map[int]struct{}
	removedsubscribed_comments map[int]struct{}
	clearedsubscribed_comments bool
	done                       bool
	oldValue                   func(context.Context) (*User, error)
	predicates                 []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserName sets the "userName" field.
func (m *UserMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the value of the "userName" field in the mutation.
func (m *UserMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "userName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName resets all changes to the "userName" field.
func (m *UserMutation) ResetUserName() {
	m.userName = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetDisplayName sets the "displayName" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.displayName = &s
}

// DisplayName returns the value of the "displayName" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.displayName
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "displayName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "displayName" field.
func (m *UserMutation) ClearDisplayName() {
	m.displayName = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "displayName" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "displayName" field.
func (m *UserMutation) ResetDisplayName() {
	m.displayName = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetAvatarUrl sets the "avatarUrl" field.
func (m *UserMutation) SetAvatarUrl(s string) {
	m.avatarUrl = &s
}

// AvatarUrl returns the value of the "avatarUrl" field in the mutation.
func (m *UserMutation) AvatarUrl() (r string, exists bool) {
	v := m.avatarUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarUrl returns the old "avatarUrl" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarUrl: %w", err)
	}
	return oldValue.AvatarUrl, nil
}

// ClearAvatarUrl clears the value of the "avatarUrl" field.
func (m *UserMutation) ClearAvatarUrl() {
	m.avatarUrl = nil
	m.clearedFields[user.FieldAvatarUrl] = struct{}{}
}

// AvatarUrlCleared returns if the "avatarUrl" field was cleared in this mutation.
func (m *UserMutation) AvatarUrlCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarUrl]
	return ok
}

// ResetAvatarUrl resets all changes to the "avatarUrl" field.
func (m *UserMutation) ResetAvatarUrl() {
	m.avatarUrl = nil
	delete(m.clearedFields, user.FieldAvatarUrl)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// AddForumIDs adds the "forums" edge to the Forum entity by ids.
func (m *UserMutation) AddForumIDs(ids ...int) {
	if m.forums == nil {
		m.forums = make(map[int]struct{})
	}
	for i := range ids {
		m.forums[ids[i]] = struct{}{}
	}
}

// ClearForums clears the "forums" edge to the Forum entity.
func (m *UserMutation) ClearForums() {
	m.clearedforums = true
}

// ForumsCleared reports if the "forums" edge to the Forum entity was cleared.
func (m *UserMutation) ForumsCleared() bool {
	return m.clearedforums
}

// RemoveForumIDs removes the "forums" edge to the Forum entity by IDs.
func (m *UserMutation) RemoveForumIDs(ids ...int) {
	if m.removedforums == nil {
		m.removedforums = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.forums, ids[i])
		m.removedforums[ids[i]] = struct{}{}
	}
}

// RemovedForums returns the removed IDs of the "forums" edge to the Forum entity.
func (m *UserMutation) RemovedForumsIDs() (ids []int) {
	for id := range m.removedforums {
		ids = append(ids, id)
	}
	return
}

// ForumsIDs returns the "forums" edge IDs in the mutation.
func (m *UserMutation) ForumsIDs() (ids []int) {
	for id := range m.forums {
		ids = append(ids, id)
	}
	return
}

// ResetForums resets all changes to the "forums" edge.
func (m *UserMutation) ResetForums() {
	m.forums = nil
	m.clearedforums = false
	m.removedforums = nil
}

// AddTopicIDs adds the "topics" edge to the Topic entity by ids.
func (m *UserMutation) AddTopicIDs(ids ...int) {
	if m.topics == nil {
		m.topics = make(map[int]struct{})
	}
	for i := range ids {
		m.topics[ids[i]] = struct{}{}
	}
}

// ClearTopics clears the "topics" edge to the Topic entity.
func (m *UserMutation) ClearTopics() {
	m.clearedtopics = true
}

// TopicsCleared reports if the "topics" edge to the Topic entity was cleared.
func (m *UserMutation) TopicsCleared() bool {
	return m.clearedtopics
}

// RemoveTopicIDs removes the "topics" edge to the Topic entity by IDs.
func (m *UserMutation) RemoveTopicIDs(ids ...int) {
	if m.removedtopics == nil {
		m.removedtopics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.topics, ids[i])
		m.removedtopics[ids[i]] = struct{}{}
	}
}

// RemovedTopics returns the removed IDs of the "topics" edge to the Topic entity.
func (m *UserMutation) RemovedTopicsIDs() (ids []int) {
	for id := range m.removedtopics {
		ids = append(ids, id)
	}
	return
}

// TopicsIDs returns the "topics" edge IDs in the mutation.
func (m *UserMutation) TopicsIDs() (ids []int) {
	for id := range m.topics {
		ids = append(ids, id)
	}
	return
}

// ResetTopics resets all changes to the "topics" edge.
func (m *UserMutation) ResetTopics() {
	m.topics = nil
	m.clearedtopics = false
	m.removedtopics = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikedForumIDs adds the "liked_forums" edge to the Forum entity by ids.
func (m *UserMutation) AddLikedForumIDs(ids ...int) {
	if m.liked_forums == nil {
		m.liked_forums = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_forums[ids[i]] = struct{}{}
	}
}

// ClearLikedForums clears the "liked_forums" edge to the Forum entity.
func (m *UserMutation) ClearLikedForums() {
	m.clearedliked_forums = true
}

// LikedForumsCleared reports if the "liked_forums" edge to the Forum entity was cleared.
func (m *UserMutation) LikedForumsCleared() bool {
	return m.clearedliked_forums
}

// RemoveLikedForumIDs removes the "liked_forums" edge to the Forum entity by IDs.
func (m *UserMutation) RemoveLikedForumIDs(ids ...int) {
	if m.removedliked_forums == nil {
		m.removedliked_forums = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_forums, ids[i])
		m.removedliked_forums[ids[i]] = struct{}{}
	}
}

// RemovedLikedForums returns the removed IDs of the "liked_forums" edge to the Forum entity.
func (m *UserMutation) RemovedLikedForumsIDs() (ids []int) {
	for id := range m.removedliked_forums {
		ids = append(ids, id)
	}
	return
}

// LikedForumsIDs returns the "liked_forums" edge IDs in the mutation.
func (m *UserMutation) LikedForumsIDs() (ids []int) {
	for id := range m.liked_forums {
		ids = append(ids, id)
	}
	return
}

// ResetLikedForums resets all changes to the "liked_forums" edge.
func (m *UserMutation) ResetLikedForums() {
	m.liked_forums = nil
	m.clearedliked_forums = false
	m.removedliked_forums = nil
}

// AddLikedTopicIDs adds the "liked_topics" edge to the Topic entity by ids.
func (m *UserMutation) AddLikedTopicIDs(ids ...int) {
	if m.liked_topics == nil {
		m.liked_topics = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_topics[ids[i]] = struct{}{}
	}
}

// ClearLikedTopics clears the "liked_topics" edge to the Topic entity.
func (m *UserMutation) ClearLikedTopics() {
	m.clearedliked_topics = true
}

// LikedTopicsCleared reports if the "liked_topics" edge to the Topic entity was cleared.
func (m *UserMutation) LikedTopicsCleared() bool {
	return m.clearedliked_topics
}

// RemoveLikedTopicIDs removes the "liked_topics" edge to the Topic entity by IDs.
func (m *UserMutation) RemoveLikedTopicIDs(ids ...int) {
	if m.removedliked_topics == nil {
		m.removedliked_topics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_topics, ids[i])
		m.removedliked_topics[ids[i]] = struct{}{}
	}
}

// RemovedLikedTopics returns the removed IDs of the "liked_topics" edge to the Topic entity.
func (m *UserMutation) RemovedLikedTopicsIDs() (ids []int) {
	for id := range m.removedliked_topics {
		ids = append(ids, id)
	}
	return
}

// LikedTopicsIDs returns the "liked_topics" edge IDs in the mutation.
func (m *UserMutation) LikedTopicsIDs() (ids []int) {
	for id := range m.liked_topics {
		ids = append(ids, id)
	}
	return
}

// ResetLikedTopics resets all changes to the "liked_topics" edge.
func (m *UserMutation) ResetLikedTopics() {
	m.liked_topics = nil
	m.clearedliked_topics = false
	m.removedliked_topics = nil
}

// AddLikedCommentIDs adds the "liked_comments" edge to the Comment entity by ids.
func (m *UserMutation) AddLikedCommentIDs(ids ...int) {
	if m.liked_comments == nil {
		m.liked_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.liked_comments[ids[i]] = struct{}{}
	}
}

// ClearLikedComments clears the "liked_comments" edge to the Comment entity.
func (m *UserMutation) ClearLikedComments() {
	m.clearedliked_comments = true
}

// LikedCommentsCleared reports if the "liked_comments" edge to the Comment entity was cleared.
func (m *UserMutation) LikedCommentsCleared() bool {
	return m.clearedliked_comments
}

// RemoveLikedCommentIDs removes the "liked_comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveLikedCommentIDs(ids ...int) {
	if m.removedliked_comments == nil {
		m.removedliked_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.liked_comments, ids[i])
		m.removedliked_comments[ids[i]] = struct{}{}
	}
}

// RemovedLikedComments returns the removed IDs of the "liked_comments" edge to the Comment entity.
func (m *UserMutation) RemovedLikedCommentsIDs() (ids []int) {
	for id := range m.removedliked_comments {
		ids = append(ids, id)
	}
	return
}

// LikedCommentsIDs returns the "liked_comments" edge IDs in the mutation.
func (m *UserMutation) LikedCommentsIDs() (ids []int) {
	for id := range m.liked_comments {
		ids = append(ids, id)
	}
	return
}

// ResetLikedComments resets all changes to the "liked_comments" edge.
func (m *UserMutation) ResetLikedComments() {
	m.liked_comments = nil
	m.clearedliked_comments = false
	m.removedliked_comments = nil
}

// AddSubscribedForumIDs adds the "subscribed_forums" edge to the Forum entity by ids.
func (m *UserMutation) AddSubscribedForumIDs(ids ...int) {
	if m.subscribed_forums == nil {
		m.subscribed_forums = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_forums[ids[i]] = struct{}{}
	}
}

// ClearSubscribedForums clears the "subscribed_forums" edge to the Forum entity.
func (m *UserMutation) ClearSubscribedForums() {
	m.clearedsubscribed_forums = true
}

// SubscribedForumsCleared reports if the "subscribed_forums" edge to the Forum entity was cleared.
func (m *UserMutation) SubscribedForumsCleared() bool {
	return m.clearedsubscribed_forums
}

// RemoveSubscribedForumIDs removes the "subscribed_forums" edge to the Forum entity by IDs.
func (m *UserMutation) RemoveSubscribedForumIDs(ids ...int) {
	if m.removedsubscribed_forums == nil {
		m.removedsubscribed_forums = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_forums, ids[i])
		m.removedsubscribed_forums[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedForums returns the removed IDs of the "subscribed_forums" edge to the Forum entity.
func (m *UserMutation) RemovedSubscribedForumsIDs() (ids []int) {
	for id := range m.removedsubscribed_forums {
		ids = append(ids, id)
	}
	return
}

// SubscribedForumsIDs returns the "subscribed_forums" edge IDs in the mutation.
func (m *UserMutation) SubscribedForumsIDs() (ids []int) {
	for id := range m.subscribed_forums {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedForums resets all changes to the "subscribed_forums" edge.
func (m *UserMutation) ResetSubscribedForums() {
	m.subscribed_forums = nil
	m.clearedsubscribed_forums = false
	m.removedsubscribed_forums = nil
}

// AddSubscribedTopicIDs adds the "subscribed_topics" edge to the Topic entity by ids.
func (m *UserMutation) AddSubscribedTopicIDs(ids ...int) {
	if m.subscribed_topics == nil {
		m.subscribed_topics = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_topics[ids[i]] = struct{}{}
	}
}

// ClearSubscribedTopics clears the "subscribed_topics" edge to the Topic entity.
func (m *UserMutation) ClearSubscribedTopics() {
	m.clearedsubscribed_topics = true
}

// SubscribedTopicsCleared reports if the "subscribed_topics" edge to the Topic entity was cleared.
func (m *UserMutation) SubscribedTopicsCleared() bool {
	return m.clearedsubscribed_topics
}

// RemoveSubscribedTopicIDs removes the "subscribed_topics" edge to the Topic entity by IDs.
func (m *UserMutation) RemoveSubscribedTopicIDs(ids ...int) {
	if m.removedsubscribed_topics == nil {
		m.removedsubscribed_topics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_topics, ids[i])
		m.removedsubscribed_topics[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedTopics returns the removed IDs of the "subscribed_topics" edge to the Topic entity.
func (m *UserMutation) RemovedSubscribedTopicsIDs() (ids []int) {
	for id := range m.removedsubscribed_topics {
		ids = append(ids, id)
	}
	return
}

// SubscribedTopicsIDs returns the "subscribed_topics" edge IDs in the mutation.
func (m *UserMutation) SubscribedTopicsIDs() (ids []int) {
	for id := range m.subscribed_topics {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedTopics resets all changes to the "subscribed_topics" edge.
func (m *UserMutation) ResetSubscribedTopics() {
	m.subscribed_topics = nil
	m.clearedsubscribed_topics = false
	m.removedsubscribed_topics = nil
}

// AddSubscribedCommentIDs adds the "subscribed_comments" edge to the Comment entity by ids.
func (m *UserMutation) AddSubscribedCommentIDs(ids ...int) {
	if m.subscribed_comments == nil {
		m.subscribed_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.subscribed_comments[ids[i]] = struct{}{}
	}
}

// ClearSubscribedComments clears the "subscribed_comments" edge to the Comment entity.
func (m *UserMutation) ClearSubscribedComments() {
	m.clearedsubscribed_comments = true
}

// SubscribedCommentsCleared reports if the "subscribed_comments" edge to the Comment entity was cleared.
func (m *UserMutation) SubscribedCommentsCleared() bool {
	return m.clearedsubscribed_comments
}

// RemoveSubscribedCommentIDs removes the "subscribed_comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveSubscribedCommentIDs(ids ...int) {
	if m.removedsubscribed_comments == nil {
		m.removedsubscribed_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscribed_comments, ids[i])
		m.removedsubscribed_comments[ids[i]] = struct{}{}
	}
}

// RemovedSubscribedComments returns the removed IDs of the "subscribed_comments" edge to the Comment entity.
func (m *UserMutation) RemovedSubscribedCommentsIDs() (ids []int) {
	for id := range m.removedsubscribed_comments {
		ids = append(ids, id)
	}
	return
}

// SubscribedCommentsIDs returns the "subscribed_comments" edge IDs in the mutation.
func (m *UserMutation) SubscribedCommentsIDs() (ids []int) {
	for id := range m.subscribed_comments {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribedComments resets all changes to the "subscribed_comments" edge.
func (m *UserMutation) ResetSubscribedComments() {
	m.subscribed_comments = nil
	m.clearedsubscribed_comments = false
	m.removedsubscribed_comments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.userName != nil {
		fields = append(fields, user.FieldUserName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.displayName != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.avatarUrl != nil {
		fields = append(fields, user.FieldAvatarUrl)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserName:
		return m.UserName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldAvatarUrl:
		return m.AvatarUrl()
	case user.FieldStatus:
		return m.Status()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUserName:
		return m.OldUserName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldAvatarUrl:
		return m.OldAvatarUrl(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldAvatarUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarUrl(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldAvatarUrl) {
		fields = append(fields, user.FieldAvatarUrl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldAvatarUrl:
		m.ClearAvatarUrl()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUserName:
		m.ResetUserName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldAvatarUrl:
		m.ResetAvatarUrl()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.forums != nil {
		edges = append(edges, user.EdgeForums)
	}
	if m.topics != nil {
		edges = append(edges, user.EdgeTopics)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.liked_forums != nil {
		edges = append(edges, user.EdgeLikedForums)
	}
	if m.liked_topics != nil {
		edges = append(edges, user.EdgeLikedTopics)
	}
	if m.liked_comments != nil {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.subscribed_forums != nil {
		edges = append(edges, user.EdgeSubscribedForums)
	}
	if m.subscribed_topics != nil {
		edges = append(edges, user.EdgeSubscribedTopics)
	}
	if m.subscribed_comments != nil {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeForums:
		ids := make([]ent.Value, 0, len(m.forums))
		for id := range m.forums {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTopics:
		ids := make([]ent.Value, 0, len(m.topics))
		for id := range m.topics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedForums:
		ids := make([]ent.Value, 0, len(m.liked_forums))
		for id := range m.liked_forums {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedTopics:
		ids := make([]ent.Value, 0, len(m.liked_topics))
		for id := range m.liked_topics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedComments:
		ids := make([]ent.Value, 0, len(m.liked_comments))
		for id := range m.liked_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedForums:
		ids := make([]ent.Value, 0, len(m.subscribed_forums))
		for id := range m.subscribed_forums {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedTopics:
		ids := make([]ent.Value, 0, len(m.subscribed_topics))
		for id := range m.subscribed_topics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedComments:
		ids := make([]ent.Value, 0, len(m.subscribed_comments))
		for id := range m.subscribed_comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedforums != nil {
		edges = append(edges, user.EdgeForums)
	}
	if m.removedtopics != nil {
		edges = append(edges, user.EdgeTopics)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedliked_forums != nil {
		edges = append(edges, user.EdgeLikedForums)
	}
	if m.removedliked_topics != nil {
		edges = append(edges, user.EdgeLikedTopics)
	}
	if m.removedliked_comments != nil {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.removedsubscribed_forums != nil {
		edges = append(edges, user.EdgeSubscribedForums)
	}
	if m.removedsubscribed_topics != nil {
		edges = append(edges, user.EdgeSubscribedTopics)
	}
	if m.removedsubscribed_comments != nil {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeForums:
		ids := make([]ent.Value, 0, len(m.removedforums))
		for id := range m.removedforums {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTopics:
		ids := make([]ent.Value, 0, len(m.removedtopics))
		for id := range m.removedtopics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedForums:
		ids := make([]ent.Value, 0, len(m.removedliked_forums))
		for id := range m.removedliked_forums {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedTopics:
		ids := make([]ent.Value, 0, len(m.removedliked_topics))
		for id := range m.removedliked_topics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikedComments:
		ids := make([]ent.Value, 0, len(m.removedliked_comments))
		for id := range m.removedliked_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedForums:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_forums))
		for id := range m.removedsubscribed_forums {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedTopics:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_topics))
		for id := range m.removedsubscribed_topics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscribedComments:
		ids := make([]ent.Value, 0, len(m.removedsubscribed_comments))
		for id := range m.removedsubscribed_comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedforums {
		edges = append(edges, user.EdgeForums)
	}
	if m.clearedtopics {
		edges = append(edges, user.EdgeTopics)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedliked_forums {
		edges = append(edges, user.EdgeLikedForums)
	}
	if m.clearedliked_topics {
		edges = append(edges, user.EdgeLikedTopics)
	}
	if m.clearedliked_comments {
		edges = append(edges, user.EdgeLikedComments)
	}
	if m.clearedsubscribed_forums {
		edges = append(edges, user.EdgeSubscribedForums)
	}
	if m.clearedsubscribed_topics {
		edges = append(edges, user.EdgeSubscribedTopics)
	}
	if m.clearedsubscribed_comments {
		edges = append(edges, user.EdgeSubscribedComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeForums:
		return m.clearedforums
	case user.EdgeTopics:
		return m.clearedtopics
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeLikedForums:
		return m.clearedliked_forums
	case user.EdgeLikedTopics:
		return m.clearedliked_topics
	case user.EdgeLikedComments:
		return m.clearedliked_comments
	case user.EdgeSubscribedForums:
		return m.clearedsubscribed_forums
	case user.EdgeSubscribedTopics:
		return m.clearedsubscribed_topics
	case user.EdgeSubscribedComments:
		return m.clearedsubscribed_comments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeForums:
		m.ResetForums()
		return nil
	case user.EdgeTopics:
		m.ResetTopics()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeLikedForums:
		m.ResetLikedForums()
		return nil
	case user.EdgeLikedTopics:
		m.ResetLikedTopics()
		return nil
	case user.EdgeLikedComments:
		m.ResetLikedComments()
		return nil
	case user.EdgeSubscribedForums:
		m.ResetSubscribedForums()
		return nil
	case user.EdgeSubscribedTopics:
		m.ResetSubscribedTopics()
		return nil
	case user.EdgeSubscribedComments:
		m.ResetSubscribedComments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserCommentLikeMutation represents an operation that mutates the UserCommentLike nodes in the graph.
type UserCommentLikeMutation struct {
	config
	op             Op
	typ            string
	_type          *usercommentlike.Type
	likedAt        *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*UserCommentLike, error)
	predicates     []predicate.UserCommentLike
}

var _ ent.Mutation = (*UserCommentLikeMutation)(nil)

// usercommentlikeOption allows management of the mutation configuration using functional options.
type usercommentlikeOption func(*UserCommentLikeMutation)

// newUserCommentLikeMutation creates new mutation for the UserCommentLike entity.
func newUserCommentLikeMutation(c config, op Op, opts ...usercommentlikeOption) *UserCommentLikeMutation {
	m := &UserCommentLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCommentLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCommentLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCommentLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserCommentLikeMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserCommentLikeMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserCommentLikeMutation) ResetUserId() {
	m.user = nil
}

// SetCommentId sets the "commentId" field.
func (m *UserCommentLikeMutation) SetCommentId(i int) {
	m.comment = &i
}

// CommentId returns the value of the "commentId" field in the mutation.
func (m *UserCommentLikeMutation) CommentId() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentId resets all changes to the "commentId" field.
func (m *UserCommentLikeMutation) ResetCommentId() {
	m.comment = nil
}

// SetType sets the "type" field.
func (m *UserCommentLikeMutation) SetType(u usercommentlike.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserCommentLikeMutation) GetType() (r usercommentlike.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *UserCommentLikeMutation) ResetType() {
	m._type = nil
}

// SetLikedAt sets the "likedAt" field.
func (m *UserCommentLikeMutation) SetLikedAt(t time.Time) {
	m.likedAt = &t
}

// LikedAt returns the value of the "likedAt" field in the mutation.
func (m *UserCommentLikeMutation) LikedAt() (r time.Time, exists bool) {
	v := m.likedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikedAt resets all changes to the "likedAt" field.
func (m *UserCommentLikeMutation) ResetLikedAt() {
	m.likedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserCommentLikeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserCommentLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usercommentlike.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserCommentLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserCommentLikeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCommentLikeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCommentLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *UserCommentLikeMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *UserCommentLikeMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[usercommentlike.FieldCommentId] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *UserCommentLikeMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *UserCommentLikeMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *UserCommentLikeMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *UserCommentLikeMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the UserCommentLikeMutation builder.
func (m *UserCommentLikeMutation) Where(ps ...predicate.UserCommentLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCommentLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCommentLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCommentLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCommentLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCommentLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCommentLike).
func (m *UserCommentLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCommentLikeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, usercommentlike.FieldUserId)
	}
	if m.comment != nil {
		fields = append(fields, usercommentlike.FieldCommentId)
	}
	if m._type != nil {
		fields = append(fields, usercommentlike.FieldType)
	}
	if m.likedAt != nil {
		fields = append(fields, usercommentlike.FieldLikedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCommentLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercommentlike.FieldUserId:
		return m.UserId()
	case usercommentlike.FieldCommentId:
		return m.CommentId()
	case usercommentlike.FieldType:
		return m.GetType()
	case usercommentlike.FieldLikedAt:
		return m.LikedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCommentLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserCommentLike does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercommentlike.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case usercommentlike.FieldCommentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentId(v)
		return nil
	case usercommentlike.FieldType:
		v, ok := value.(usercommentlike.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case usercommentlike.FieldLikedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCommentLikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCommentLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCommentLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCommentLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCommentLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCommentLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCommentLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCommentLikeMutation) ResetField(name string) error {
	switch name {
	case usercommentlike.FieldUserId:
		m.ResetUserId()
		return nil
	case usercommentlike.FieldCommentId:
		m.ResetCommentId()
		return nil
	case usercommentlike.FieldType:
		m.ResetType()
		return nil
	case usercommentlike.FieldLikedAt:
		m.ResetLikedAt()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCommentLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usercommentlike.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, usercommentlike.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCommentLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercommentlike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usercommentlike.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCommentLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCommentLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCommentLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usercommentlike.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, usercommentlike.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCommentLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case usercommentlike.EdgeUser:
		return m.cleareduser
	case usercommentlike.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCommentLikeMutation) ClearEdge(name string) error {
	switch name {
	case usercommentlike.EdgeUser:
		m.ClearUser()
		return nil
	case usercommentlike.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCommentLikeMutation) ResetEdge(name string) error {
	switch name {
	case usercommentlike.EdgeUser:
		m.ResetUser()
		return nil
	case usercommentlike.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentLike edge %s", name)
}

// UserCommentSubscriptionMutation represents an operation that mutates the UserCommentSubscription nodes in the graph.
type UserCommentSubscriptionMutation struct {
	config
	op             Op
	typ            string
	isNotified     *bool
	subscribedAt   *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*UserCommentSubscription, error)
	predicates     []predicate.UserCommentSubscription
}

var _ ent.Mutation = (*UserCommentSubscriptionMutation)(nil)

// usercommentsubscriptionOption allows management of the mutation configuration using functional options.
type usercommentsubscriptionOption func(*UserCommentSubscriptionMutation)

// newUserCommentSubscriptionMutation creates new mutation for the UserCommentSubscription entity.
func newUserCommentSubscriptionMutation(c config, op Op, opts ...usercommentsubscriptionOption) *UserCommentSubscriptionMutation {
	m := &UserCommentSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCommentSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCommentSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCommentSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserCommentSubscriptionMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserCommentSubscriptionMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserCommentSubscriptionMutation) ResetUserId() {
	m.user = nil
}

// SetCommentId sets the "commentId" field.
func (m *UserCommentSubscriptionMutation) SetCommentId(i int) {
	m.comment = &i
}

// CommentId returns the value of the "commentId" field in the mutation.
func (m *UserCommentSubscriptionMutation) CommentId() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentId resets all changes to the "commentId" field.
func (m *UserCommentSubscriptionMutation) ResetCommentId() {
	m.comment = nil
}

// SetIsNotified sets the "isNotified" field.
func (m *UserCommentSubscriptionMutation) SetIsNotified(b bool) {
	m.isNotified = &b
}

// IsNotified returns the value of the "isNotified" field in the mutation.
func (m *UserCommentSubscriptionMutation) IsNotified() (r bool, exists bool) {
	v := m.isNotified
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsNotified resets all changes to the "isNotified" field.
func (m *UserCommentSubscriptionMutation) ResetIsNotified() {
	m.isNotified = nil
}

// SetSubscribedAt sets the "subscribedAt" field.
func (m *UserCommentSubscriptionMutation) SetSubscribedAt(t time.Time) {
	m.subscribedAt = &t
}

// SubscribedAt returns the value of the "subscribedAt" field in the mutation.
func (m *UserCommentSubscriptionMutation) SubscribedAt() (r time.Time, exists bool) {
	v := m.subscribedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribedAt resets all changes to the "subscribedAt" field.
func (m *UserCommentSubscriptionMutation) ResetSubscribedAt() {
	m.subscribedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserCommentSubscriptionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserCommentSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usercommentsubscription.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserCommentSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserCommentSubscriptionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCommentSubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCommentSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCommentID sets the "comment" edge to the Comment entity by id.
func (m *UserCommentSubscriptionMutation) SetCommentID(id int) {
	m.comment = &id
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *UserCommentSubscriptionMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[usercommentsubscription.FieldCommentId] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *UserCommentSubscriptionMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentID returns the "comment" edge ID in the mutation.
func (m *UserCommentSubscriptionMutation) CommentID() (id int, exists bool) {
	if m.comment != nil {
		return *m.comment, true
	}
	return
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *UserCommentSubscriptionMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *UserCommentSubscriptionMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the UserCommentSubscriptionMutation builder.
func (m *UserCommentSubscriptionMutation) Where(ps ...predicate.UserCommentSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCommentSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCommentSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCommentSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCommentSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCommentSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCommentSubscription).
func (m *UserCommentSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCommentSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, usercommentsubscription.FieldUserId)
	}
	if m.comment != nil {
		fields = append(fields, usercommentsubscription.FieldCommentId)
	}
	if m.isNotified != nil {
		fields = append(fields, usercommentsubscription.FieldIsNotified)
	}
	if m.subscribedAt != nil {
		fields = append(fields, usercommentsubscription.FieldSubscribedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCommentSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercommentsubscription.FieldUserId:
		return m.UserId()
	case usercommentsubscription.FieldCommentId:
		return m.CommentId()
	case usercommentsubscription.FieldIsNotified:
		return m.IsNotified()
	case usercommentsubscription.FieldSubscribedAt:
		return m.SubscribedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCommentSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserCommentSubscription does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercommentsubscription.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case usercommentsubscription.FieldCommentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentId(v)
		return nil
	case usercommentsubscription.FieldIsNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotified(v)
		return nil
	case usercommentsubscription.FieldSubscribedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCommentSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCommentSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCommentSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCommentSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCommentSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCommentSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCommentSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usercommentsubscription.FieldUserId:
		m.ResetUserId()
		return nil
	case usercommentsubscription.FieldCommentId:
		m.ResetCommentId()
		return nil
	case usercommentsubscription.FieldIsNotified:
		m.ResetIsNotified()
		return nil
	case usercommentsubscription.FieldSubscribedAt:
		m.ResetSubscribedAt()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCommentSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usercommentsubscription.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, usercommentsubscription.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCommentSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercommentsubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usercommentsubscription.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCommentSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCommentSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCommentSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usercommentsubscription.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, usercommentsubscription.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCommentSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usercommentsubscription.EdgeUser:
		return m.cleareduser
	case usercommentsubscription.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case usercommentsubscription.EdgeUser:
		m.ClearUser()
		return nil
	case usercommentsubscription.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCommentSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case usercommentsubscription.EdgeUser:
		m.ResetUser()
		return nil
	case usercommentsubscription.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown UserCommentSubscription edge %s", name)
}

// UserForumLikeMutation represents an operation that mutates the UserForumLike nodes in the graph.
type UserForumLikeMutation struct {
	config
	op            Op
	typ           string
	_type         *userforumlike.Type
	likedAt       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	forum         *int
	clearedforum  bool
	done          bool
	oldValue      func(context.Context) (*UserForumLike, error)
	predicates    []predicate.UserForumLike
}

var _ ent.Mutation = (*UserForumLikeMutation)(nil)

// userforumlikeOption allows management of the mutation configuration using functional options.
type userforumlikeOption func(*UserForumLikeMutation)

// newUserForumLikeMutation creates new mutation for the UserForumLike entity.
func newUserForumLikeMutation(c config, op Op, opts ...userforumlikeOption) *UserForumLikeMutation {
	m := &UserForumLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserForumLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserForumLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserForumLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserForumLikeMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserForumLikeMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserForumLikeMutation) ResetUserId() {
	m.user = nil
}

// SetForumId sets the "forumId" field.
func (m *UserForumLikeMutation) SetForumId(i int) {
	m.forum = &i
}

// ForumId returns the value of the "forumId" field in the mutation.
func (m *UserForumLikeMutation) ForumId() (r int, exists bool) {
	v := m.forum
	if v == nil {
		return
	}
	return *v, true
}

// ResetForumId resets all changes to the "forumId" field.
func (m *UserForumLikeMutation) ResetForumId() {
	m.forum = nil
}

// SetType sets the "type" field.
func (m *UserForumLikeMutation) SetType(u userforumlike.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserForumLikeMutation) GetType() (r userforumlike.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *UserForumLikeMutation) ResetType() {
	m._type = nil
}

// SetLikedAt sets the "likedAt" field.
func (m *UserForumLikeMutation) SetLikedAt(t time.Time) {
	m.likedAt = &t
}

// LikedAt returns the value of the "likedAt" field in the mutation.
func (m *UserForumLikeMutation) LikedAt() (r time.Time, exists bool) {
	v := m.likedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikedAt resets all changes to the "likedAt" field.
func (m *UserForumLikeMutation) ResetLikedAt() {
	m.likedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserForumLikeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserForumLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userforumlike.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserForumLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserForumLikeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserForumLikeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserForumLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetForumID sets the "forum" edge to the Forum entity by id.
func (m *UserForumLikeMutation) SetForumID(id int) {
	m.forum = &id
}

// ClearForum clears the "forum" edge to the Forum entity.
func (m *UserForumLikeMutation) ClearForum() {
	m.clearedforum = true
	m.clearedFields[userforumlike.FieldForumId] = struct{}{}
}

// ForumCleared reports if the "forum" edge to the Forum entity was cleared.
func (m *UserForumLikeMutation) ForumCleared() bool {
	return m.clearedforum
}

// ForumID returns the "forum" edge ID in the mutation.
func (m *UserForumLikeMutation) ForumID() (id int, exists bool) {
	if m.forum != nil {
		return *m.forum, true
	}
	return
}

// ForumIDs returns the "forum" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ForumID instead. It exists only for internal usage by the builders.
func (m *UserForumLikeMutation) ForumIDs() (ids []int) {
	if id := m.forum; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetForum resets all changes to the "forum" edge.
func (m *UserForumLikeMutation) ResetForum() {
	m.forum = nil
	m.clearedforum = false
}

// Where appends a list predicates to the UserForumLikeMutation builder.
func (m *UserForumLikeMutation) Where(ps ...predicate.UserForumLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserForumLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserForumLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserForumLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserForumLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserForumLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserForumLike).
func (m *UserForumLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserForumLikeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, userforumlike.FieldUserId)
	}
	if m.forum != nil {
		fields = append(fields, userforumlike.FieldForumId)
	}
	if m._type != nil {
		fields = append(fields, userforumlike.FieldType)
	}
	if m.likedAt != nil {
		fields = append(fields, userforumlike.FieldLikedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserForumLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userforumlike.FieldUserId:
		return m.UserId()
	case userforumlike.FieldForumId:
		return m.ForumId()
	case userforumlike.FieldType:
		return m.GetType()
	case userforumlike.FieldLikedAt:
		return m.LikedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserForumLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserForumLike does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserForumLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userforumlike.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userforumlike.FieldForumId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForumId(v)
		return nil
	case userforumlike.FieldType:
		v, ok := value.(userforumlike.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case userforumlike.FieldLikedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserForumLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserForumLikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserForumLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserForumLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserForumLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserForumLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserForumLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserForumLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserForumLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserForumLikeMutation) ResetField(name string) error {
	switch name {
	case userforumlike.FieldUserId:
		m.ResetUserId()
		return nil
	case userforumlike.FieldForumId:
		m.ResetForumId()
		return nil
	case userforumlike.FieldType:
		m.ResetType()
		return nil
	case userforumlike.FieldLikedAt:
		m.ResetLikedAt()
		return nil
	}
	return fmt.Errorf("unknown UserForumLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserForumLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userforumlike.EdgeUser)
	}
	if m.forum != nil {
		edges = append(edges, userforumlike.EdgeForum)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserForumLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userforumlike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userforumlike.EdgeForum:
		if id := m.forum; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserForumLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserForumLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserForumLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userforumlike.EdgeUser)
	}
	if m.clearedforum {
		edges = append(edges, userforumlike.EdgeForum)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserForumLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case userforumlike.EdgeUser:
		return m.cleareduser
	case userforumlike.EdgeForum:
		return m.clearedforum
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserForumLikeMutation) ClearEdge(name string) error {
	switch name {
	case userforumlike.EdgeUser:
		m.ClearUser()
		return nil
	case userforumlike.EdgeForum:
		m.ClearForum()
		return nil
	}
	return fmt.Errorf("unknown UserForumLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserForumLikeMutation) ResetEdge(name string) error {
	switch name {
	case userforumlike.EdgeUser:
		m.ResetUser()
		return nil
	case userforumlike.EdgeForum:
		m.ResetForum()
		return nil
	}
	return fmt.Errorf("unknown UserForumLike edge %s", name)
}

// UserForumSubscriptionMutation represents an operation that mutates the UserForumSubscription nodes in the graph.
type UserForumSubscriptionMutation struct {
	config
	op            Op
	typ           string
	isNotified    *bool
	subscribedAt  *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	forum         *int
	clearedforum  bool
	done          bool
	oldValue      func(context.Context) (*UserForumSubscription, error)
	predicates    []predicate.UserForumSubscription
}

var _ ent.Mutation = (*UserForumSubscriptionMutation)(nil)

// userforumsubscriptionOption allows management of the mutation configuration using functional options.
type userforumsubscriptionOption func(*UserForumSubscriptionMutation)

// newUserForumSubscriptionMutation creates new mutation for the UserForumSubscription entity.
func newUserForumSubscriptionMutation(c config, op Op, opts ...userforumsubscriptionOption) *UserForumSubscriptionMutation {
	m := &UserForumSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserForumSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserForumSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserForumSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserForumSubscriptionMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserForumSubscriptionMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserForumSubscriptionMutation) ResetUserId() {
	m.user = nil
}

// SetForumId sets the "forumId" field.
func (m *UserForumSubscriptionMutation) SetForumId(i int) {
	m.forum = &i
}

// ForumId returns the value of the "forumId" field in the mutation.
func (m *UserForumSubscriptionMutation) ForumId() (r int, exists bool) {
	v := m.forum
	if v == nil {
		return
	}
	return *v, true
}

// ResetForumId resets all changes to the "forumId" field.
func (m *UserForumSubscriptionMutation) ResetForumId() {
	m.forum = nil
}

// SetIsNotified sets the "isNotified" field.
func (m *UserForumSubscriptionMutation) SetIsNotified(b bool) {
	m.isNotified = &b
}

// IsNotified returns the value of the "isNotified" field in the mutation.
func (m *UserForumSubscriptionMutation) IsNotified() (r bool, exists bool) {
	v := m.isNotified
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsNotified resets all changes to the "isNotified" field.
func (m *UserForumSubscriptionMutation) ResetIsNotified() {
	m.isNotified = nil
}

// SetSubscribedAt sets the "subscribedAt" field.
func (m *UserForumSubscriptionMutation) SetSubscribedAt(t time.Time) {
	m.subscribedAt = &t
}

// SubscribedAt returns the value of the "subscribedAt" field in the mutation.
func (m *UserForumSubscriptionMutation) SubscribedAt() (r time.Time, exists bool) {
	v := m.subscribedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribedAt resets all changes to the "subscribedAt" field.
func (m *UserForumSubscriptionMutation) ResetSubscribedAt() {
	m.subscribedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserForumSubscriptionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserForumSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userforumsubscription.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserForumSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserForumSubscriptionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserForumSubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserForumSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetForumID sets the "forum" edge to the Forum entity by id.
func (m *UserForumSubscriptionMutation) SetForumID(id int) {
	m.forum = &id
}

// ClearForum clears the "forum" edge to the Forum entity.
func (m *UserForumSubscriptionMutation) ClearForum() {
	m.clearedforum = true
	m.clearedFields[userforumsubscription.FieldForumId] = struct{}{}
}

// ForumCleared reports if the "forum" edge to the Forum entity was cleared.
func (m *UserForumSubscriptionMutation) ForumCleared() bool {
	return m.clearedforum
}

// ForumID returns the "forum" edge ID in the mutation.
func (m *UserForumSubscriptionMutation) ForumID() (id int, exists bool) {
	if m.forum != nil {
		return *m.forum, true
	}
	return
}

// ForumIDs returns the "forum" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ForumID instead. It exists only for internal usage by the builders.
func (m *UserForumSubscriptionMutation) ForumIDs() (ids []int) {
	if id := m.forum; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetForum resets all changes to the "forum" edge.
func (m *UserForumSubscriptionMutation) ResetForum() {
	m.forum = nil
	m.clearedforum = false
}

// Where appends a list predicates to the UserForumSubscriptionMutation builder.
func (m *UserForumSubscriptionMutation) Where(ps ...predicate.UserForumSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserForumSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserForumSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserForumSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserForumSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserForumSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserForumSubscription).
func (m *UserForumSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserForumSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, userforumsubscription.FieldUserId)
	}
	if m.forum != nil {
		fields = append(fields, userforumsubscription.FieldForumId)
	}
	if m.isNotified != nil {
		fields = append(fields, userforumsubscription.FieldIsNotified)
	}
	if m.subscribedAt != nil {
		fields = append(fields, userforumsubscription.FieldSubscribedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserForumSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userforumsubscription.FieldUserId:
		return m.UserId()
	case userforumsubscription.FieldForumId:
		return m.ForumId()
	case userforumsubscription.FieldIsNotified:
		return m.IsNotified()
	case userforumsubscription.FieldSubscribedAt:
		return m.SubscribedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserForumSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserForumSubscription does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserForumSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userforumsubscription.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userforumsubscription.FieldForumId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForumId(v)
		return nil
	case userforumsubscription.FieldIsNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotified(v)
		return nil
	case userforumsubscription.FieldSubscribedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserForumSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserForumSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserForumSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserForumSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserForumSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserForumSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserForumSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserForumSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserForumSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserForumSubscriptionMutation) ResetField(name string) error {
	switch name {
	case userforumsubscription.FieldUserId:
		m.ResetUserId()
		return nil
	case userforumsubscription.FieldForumId:
		m.ResetForumId()
		return nil
	case userforumsubscription.FieldIsNotified:
		m.ResetIsNotified()
		return nil
	case userforumsubscription.FieldSubscribedAt:
		m.ResetSubscribedAt()
		return nil
	}
	return fmt.Errorf("unknown UserForumSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserForumSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userforumsubscription.EdgeUser)
	}
	if m.forum != nil {
		edges = append(edges, userforumsubscription.EdgeForum)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserForumSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userforumsubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userforumsubscription.EdgeForum:
		if id := m.forum; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserForumSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserForumSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserForumSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userforumsubscription.EdgeUser)
	}
	if m.clearedforum {
		edges = append(edges, userforumsubscription.EdgeForum)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserForumSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case userforumsubscription.EdgeUser:
		return m.cleareduser
	case userforumsubscription.EdgeForum:
		return m.clearedforum
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserForumSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case userforumsubscription.EdgeUser:
		m.ClearUser()
		return nil
	case userforumsubscription.EdgeForum:
		m.ClearForum()
		return nil
	}
	return fmt.Errorf("unknown UserForumSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserForumSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case userforumsubscription.EdgeUser:
		m.ResetUser()
		return nil
	case userforumsubscription.EdgeForum:
		m.ResetForum()
		return nil
	}
	return fmt.Errorf("unknown UserForumSubscription edge %s", name)
}

// UserTopicLikeMutation represents an operation that mutates the UserTopicLike nodes in the graph.
type UserTopicLikeMutation struct {
	config
	op            Op
	typ           string
	_type         *usertopiclike.Type
	likedAt       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	topic         *int
	clearedtopic  bool
	done          bool
	oldValue      func(context.Context) (*UserTopicLike, error)
	predicates    []predicate.UserTopicLike
}

var _ ent.Mutation = (*UserTopicLikeMutation)(nil)

// usertopiclikeOption allows management of the mutation configuration using functional options.
type usertopiclikeOption func(*UserTopicLikeMutation)

// newUserTopicLikeMutation creates new mutation for the UserTopicLike entity.
func newUserTopicLikeMutation(c config, op Op, opts ...usertopiclikeOption) *UserTopicLikeMutation {
	m := &UserTopicLikeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserTopicLike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTopicLikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTopicLikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserTopicLikeMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserTopicLikeMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserTopicLikeMutation) ResetUserId() {
	m.user = nil
}

// SetTopicId sets the "topicId" field.
func (m *UserTopicLikeMutation) SetTopicId(i int) {
	m.topic = &i
}

// TopicId returns the value of the "topicId" field in the mutation.
func (m *UserTopicLikeMutation) TopicId() (r int, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// ResetTopicId resets all changes to the "topicId" field.
func (m *UserTopicLikeMutation) ResetTopicId() {
	m.topic = nil
}

// SetType sets the "type" field.
func (m *UserTopicLikeMutation) SetType(u usertopiclike.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserTopicLikeMutation) GetType() (r usertopiclike.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *UserTopicLikeMutation) ResetType() {
	m._type = nil
}

// SetLikedAt sets the "likedAt" field.
func (m *UserTopicLikeMutation) SetLikedAt(t time.Time) {
	m.likedAt = &t
}

// LikedAt returns the value of the "likedAt" field in the mutation.
func (m *UserTopicLikeMutation) LikedAt() (r time.Time, exists bool) {
	v := m.likedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikedAt resets all changes to the "likedAt" field.
func (m *UserTopicLikeMutation) ResetLikedAt() {
	m.likedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserTopicLikeMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserTopicLikeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usertopiclike.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserTopicLikeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserTopicLikeMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserTopicLikeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserTopicLikeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetTopicID sets the "topic" edge to the Topic entity by id.
func (m *UserTopicLikeMutation) SetTopicID(id int) {
	m.topic = &id
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *UserTopicLikeMutation) ClearTopic() {
	m.clearedtopic = true
	m.clearedFields[usertopiclike.FieldTopicId] = struct{}{}
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *UserTopicLikeMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicID returns the "topic" edge ID in the mutation.
func (m *UserTopicLikeMutation) TopicID() (id int, exists bool) {
	if m.topic != nil {
		return *m.topic, true
	}
	return
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *UserTopicLikeMutation) TopicIDs() (ids []int) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *UserTopicLikeMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// Where appends a list predicates to the UserTopicLikeMutation builder.
func (m *UserTopicLikeMutation) Where(ps ...predicate.UserTopicLike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTopicLikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTopicLikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserTopicLike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTopicLikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTopicLikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserTopicLike).
func (m *UserTopicLikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTopicLikeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, usertopiclike.FieldUserId)
	}
	if m.topic != nil {
		fields = append(fields, usertopiclike.FieldTopicId)
	}
	if m._type != nil {
		fields = append(fields, usertopiclike.FieldType)
	}
	if m.likedAt != nil {
		fields = append(fields, usertopiclike.FieldLikedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTopicLikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertopiclike.FieldUserId:
		return m.UserId()
	case usertopiclike.FieldTopicId:
		return m.TopicId()
	case usertopiclike.FieldType:
		return m.GetType()
	case usertopiclike.FieldLikedAt:
		return m.LikedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTopicLikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserTopicLike does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTopicLikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertopiclike.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case usertopiclike.FieldTopicId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicId(v)
		return nil
	case usertopiclike.FieldType:
		v, ok := value.(usertopiclike.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case usertopiclike.FieldLikedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserTopicLike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTopicLikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTopicLikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTopicLikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserTopicLike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTopicLikeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTopicLikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTopicLikeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserTopicLike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTopicLikeMutation) ResetField(name string) error {
	switch name {
	case usertopiclike.FieldUserId:
		m.ResetUserId()
		return nil
	case usertopiclike.FieldTopicId:
		m.ResetTopicId()
		return nil
	case usertopiclike.FieldType:
		m.ResetType()
		return nil
	case usertopiclike.FieldLikedAt:
		m.ResetLikedAt()
		return nil
	}
	return fmt.Errorf("unknown UserTopicLike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTopicLikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usertopiclike.EdgeUser)
	}
	if m.topic != nil {
		edges = append(edges, usertopiclike.EdgeTopic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTopicLikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usertopiclike.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usertopiclike.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTopicLikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTopicLikeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTopicLikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usertopiclike.EdgeUser)
	}
	if m.clearedtopic {
		edges = append(edges, usertopiclike.EdgeTopic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTopicLikeMutation) EdgeCleared(name string) bool {
	switch name {
	case usertopiclike.EdgeUser:
		return m.cleareduser
	case usertopiclike.EdgeTopic:
		return m.clearedtopic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTopicLikeMutation) ClearEdge(name string) error {
	switch name {
	case usertopiclike.EdgeUser:
		m.ClearUser()
		return nil
	case usertopiclike.EdgeTopic:
		m.ClearTopic()
		return nil
	}
	return fmt.Errorf("unknown UserTopicLike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTopicLikeMutation) ResetEdge(name string) error {
	switch name {
	case usertopiclike.EdgeUser:
		m.ResetUser()
		return nil
	case usertopiclike.EdgeTopic:
		m.ResetTopic()
		return nil
	}
	return fmt.Errorf("unknown UserTopicLike edge %s", name)
}

// UserTopicSubscriptionMutation represents an operation that mutates the UserTopicSubscription nodes in the graph.
type UserTopicSubscriptionMutation struct {
	config
	op            Op
	typ           string
	isNotified    *bool
	subscribedAt  *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	topic         *int
	clearedtopic  bool
	done          bool
	oldValue      func(context.Context) (*UserTopicSubscription, error)
	predicates    []predicate.UserTopicSubscription
}

var _ ent.Mutation = (*UserTopicSubscriptionMutation)(nil)

// usertopicsubscriptionOption allows management of the mutation configuration using functional options.
type usertopicsubscriptionOption func(*UserTopicSubscriptionMutation)

// newUserTopicSubscriptionMutation creates new mutation for the UserTopicSubscription entity.
func newUserTopicSubscriptionMutation(c config, op Op, opts ...usertopicsubscriptionOption) *UserTopicSubscriptionMutation {
	m := &UserTopicSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserTopicSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTopicSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTopicSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserId sets the "userId" field.
func (m *UserTopicSubscriptionMutation) SetUserId(i int) {
	m.user = &i
}

// UserId returns the value of the "userId" field in the mutation.
func (m *UserTopicSubscriptionMutation) UserId() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId resets all changes to the "userId" field.
func (m *UserTopicSubscriptionMutation) ResetUserId() {
	m.user = nil
}

// SetTopicId sets the "topicId" field.
func (m *UserTopicSubscriptionMutation) SetTopicId(i int) {
	m.topic = &i
}

// TopicId returns the value of the "topicId" field in the mutation.
func (m *UserTopicSubscriptionMutation) TopicId() (r int, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// ResetTopicId resets all changes to the "topicId" field.
func (m *UserTopicSubscriptionMutation) ResetTopicId() {
	m.topic = nil
}

// SetIsNotified sets the "isNotified" field.
func (m *UserTopicSubscriptionMutation) SetIsNotified(b bool) {
	m.isNotified = &b
}

// IsNotified returns the value of the "isNotified" field in the mutation.
func (m *UserTopicSubscriptionMutation) IsNotified() (r bool, exists bool) {
	v := m.isNotified
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsNotified resets all changes to the "isNotified" field.
func (m *UserTopicSubscriptionMutation) ResetIsNotified() {
	m.isNotified = nil
}

// SetSubscribedAt sets the "subscribedAt" field.
func (m *UserTopicSubscriptionMutation) SetSubscribedAt(t time.Time) {
	m.subscribedAt = &t
}

// SubscribedAt returns the value of the "subscribedAt" field in the mutation.
func (m *UserTopicSubscriptionMutation) SubscribedAt() (r time.Time, exists bool) {
	v := m.subscribedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubscribedAt resets all changes to the "subscribedAt" field.
func (m *UserTopicSubscriptionMutation) ResetSubscribedAt() {
	m.subscribedAt = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserTopicSubscriptionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserTopicSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usertopicsubscription.FieldUserId] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserTopicSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserTopicSubscriptionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserTopicSubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserTopicSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetTopicID sets the "topic" edge to the Topic entity by id.
func (m *UserTopicSubscriptionMutation) SetTopicID(id int) {
	m.topic = &id
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *UserTopicSubscriptionMutation) ClearTopic() {
	m.clearedtopic = true
	m.clearedFields[usertopicsubscription.FieldTopicId] = struct{}{}
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *UserTopicSubscriptionMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicID returns the "topic" edge ID in the mutation.
func (m *UserTopicSubscriptionMutation) TopicID() (id int, exists bool) {
	if m.topic != nil {
		return *m.topic, true
	}
	return
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *UserTopicSubscriptionMutation) TopicIDs() (ids []int) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *UserTopicSubscriptionMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// Where appends a list predicates to the UserTopicSubscriptionMutation builder.
func (m *UserTopicSubscriptionMutation) Where(ps ...predicate.UserTopicSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTopicSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTopicSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserTopicSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTopicSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTopicSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserTopicSubscription).
func (m *UserTopicSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTopicSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, usertopicsubscription.FieldUserId)
	}
	if m.topic != nil {
		fields = append(fields, usertopicsubscription.FieldTopicId)
	}
	if m.isNotified != nil {
		fields = append(fields, usertopicsubscription.FieldIsNotified)
	}
	if m.subscribedAt != nil {
		fields = append(fields, usertopicsubscription.FieldSubscribedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTopicSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertopicsubscription.FieldUserId:
		return m.UserId()
	case usertopicsubscription.FieldTopicId:
		return m.TopicId()
	case usertopicsubscription.FieldIsNotified:
		return m.IsNotified()
	case usertopicsubscription.FieldSubscribedAt:
		return m.SubscribedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTopicSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserTopicSubscription does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTopicSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertopicsubscription.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case usertopicsubscription.FieldTopicId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicId(v)
		return nil
	case usertopicsubscription.FieldIsNotified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNotified(v)
		return nil
	case usertopicsubscription.FieldSubscribedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserTopicSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTopicSubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTopicSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTopicSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserTopicSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTopicSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTopicSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTopicSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserTopicSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTopicSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usertopicsubscription.FieldUserId:
		m.ResetUserId()
		return nil
	case usertopicsubscription.FieldTopicId:
		m.ResetTopicId()
		return nil
	case usertopicsubscription.FieldIsNotified:
		m.ResetIsNotified()
		return nil
	case usertopicsubscription.FieldSubscribedAt:
		m.ResetSubscribedAt()
		return nil
	}
	return fmt.Errorf("unknown UserTopicSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTopicSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, usertopicsubscription.EdgeUser)
	}
	if m.topic != nil {
		edges = append(edges, usertopicsubscription.EdgeTopic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTopicSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usertopicsubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usertopicsubscription.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTopicSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTopicSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTopicSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, usertopicsubscription.EdgeUser)
	}
	if m.clearedtopic {
		edges = append(edges, usertopicsubscription.EdgeTopic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTopicSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usertopicsubscription.EdgeUser:
		return m.cleareduser
	case usertopicsubscription.EdgeTopic:
		return m.clearedtopic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTopicSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case usertopicsubscription.EdgeUser:
		m.ClearUser()
		return nil
	case usertopicsubscription.EdgeTopic:
		m.ClearTopic()
		return nil
	}
	return fmt.Errorf("unknown UserTopicSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTopicSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case usertopicsubscription.EdgeUser:
		m.ResetUser()
		return nil
	case usertopicsubscription.EdgeTopic:
		m.ResetTopic()
		return nil
	}
	return fmt.Errorf("unknown UserTopicSubscription edge %s", name)
}
