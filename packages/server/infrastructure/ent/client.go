// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"server/infrastructure/ent/migrate"

	"server/infrastructure/ent/adminuser"
	"server/infrastructure/ent/board"
	"server/infrastructure/ent/comment"
	"server/infrastructure/ent/commentattachment"
	"server/infrastructure/ent/thread"
	"server/infrastructure/ent/threadtag"
	"server/infrastructure/ent/threadtagging"
	"server/infrastructure/ent/user"
	"server/infrastructure/ent/userboardlike"
	"server/infrastructure/ent/userboardsubscription"
	"server/infrastructure/ent/usercommentlike"
	"server/infrastructure/ent/usercommentsubscription"
	"server/infrastructure/ent/userthreadlike"
	"server/infrastructure/ent/userthreadsubscription"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AdminUser is the client for interacting with the AdminUser builders.
	AdminUser *AdminUserClient
	// Board is the client for interacting with the Board builders.
	Board *BoardClient
	// Comment is the client for interacting with the Comment builders.
	Comment *CommentClient
	// CommentAttachment is the client for interacting with the CommentAttachment builders.
	CommentAttachment *CommentAttachmentClient
	// Thread is the client for interacting with the Thread builders.
	Thread *ThreadClient
	// ThreadTag is the client for interacting with the ThreadTag builders.
	ThreadTag *ThreadTagClient
	// ThreadTagging is the client for interacting with the ThreadTagging builders.
	ThreadTagging *ThreadTaggingClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserBoardLike is the client for interacting with the UserBoardLike builders.
	UserBoardLike *UserBoardLikeClient
	// UserBoardSubscription is the client for interacting with the UserBoardSubscription builders.
	UserBoardSubscription *UserBoardSubscriptionClient
	// UserCommentLike is the client for interacting with the UserCommentLike builders.
	UserCommentLike *UserCommentLikeClient
	// UserCommentSubscription is the client for interacting with the UserCommentSubscription builders.
	UserCommentSubscription *UserCommentSubscriptionClient
	// UserThreadLike is the client for interacting with the UserThreadLike builders.
	UserThreadLike *UserThreadLikeClient
	// UserThreadSubscription is the client for interacting with the UserThreadSubscription builders.
	UserThreadSubscription *UserThreadSubscriptionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AdminUser = NewAdminUserClient(c.config)
	c.Board = NewBoardClient(c.config)
	c.Comment = NewCommentClient(c.config)
	c.CommentAttachment = NewCommentAttachmentClient(c.config)
	c.Thread = NewThreadClient(c.config)
	c.ThreadTag = NewThreadTagClient(c.config)
	c.ThreadTagging = NewThreadTaggingClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserBoardLike = NewUserBoardLikeClient(c.config)
	c.UserBoardSubscription = NewUserBoardSubscriptionClient(c.config)
	c.UserCommentLike = NewUserCommentLikeClient(c.config)
	c.UserCommentSubscription = NewUserCommentSubscriptionClient(c.config)
	c.UserThreadLike = NewUserThreadLikeClient(c.config)
	c.UserThreadSubscription = NewUserThreadSubscriptionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		AdminUser:               NewAdminUserClient(cfg),
		Board:                   NewBoardClient(cfg),
		Comment:                 NewCommentClient(cfg),
		CommentAttachment:       NewCommentAttachmentClient(cfg),
		Thread:                  NewThreadClient(cfg),
		ThreadTag:               NewThreadTagClient(cfg),
		ThreadTagging:           NewThreadTaggingClient(cfg),
		User:                    NewUserClient(cfg),
		UserBoardLike:           NewUserBoardLikeClient(cfg),
		UserBoardSubscription:   NewUserBoardSubscriptionClient(cfg),
		UserCommentLike:         NewUserCommentLikeClient(cfg),
		UserCommentSubscription: NewUserCommentSubscriptionClient(cfg),
		UserThreadLike:          NewUserThreadLikeClient(cfg),
		UserThreadSubscription:  NewUserThreadSubscriptionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		AdminUser:               NewAdminUserClient(cfg),
		Board:                   NewBoardClient(cfg),
		Comment:                 NewCommentClient(cfg),
		CommentAttachment:       NewCommentAttachmentClient(cfg),
		Thread:                  NewThreadClient(cfg),
		ThreadTag:               NewThreadTagClient(cfg),
		ThreadTagging:           NewThreadTaggingClient(cfg),
		User:                    NewUserClient(cfg),
		UserBoardLike:           NewUserBoardLikeClient(cfg),
		UserBoardSubscription:   NewUserBoardSubscriptionClient(cfg),
		UserCommentLike:         NewUserCommentLikeClient(cfg),
		UserCommentSubscription: NewUserCommentSubscriptionClient(cfg),
		UserThreadLike:          NewUserThreadLikeClient(cfg),
		UserThreadSubscription:  NewUserThreadSubscriptionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AdminUser.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AdminUser, c.Board, c.Comment, c.CommentAttachment, c.Thread, c.ThreadTag,
		c.ThreadTagging, c.User, c.UserBoardLike, c.UserBoardSubscription,
		c.UserCommentLike, c.UserCommentSubscription, c.UserThreadLike,
		c.UserThreadSubscription,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AdminUser, c.Board, c.Comment, c.CommentAttachment, c.Thread, c.ThreadTag,
		c.ThreadTagging, c.User, c.UserBoardLike, c.UserBoardSubscription,
		c.UserCommentLike, c.UserCommentSubscription, c.UserThreadLike,
		c.UserThreadSubscription,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AdminUserMutation:
		return c.AdminUser.mutate(ctx, m)
	case *BoardMutation:
		return c.Board.mutate(ctx, m)
	case *CommentMutation:
		return c.Comment.mutate(ctx, m)
	case *CommentAttachmentMutation:
		return c.CommentAttachment.mutate(ctx, m)
	case *ThreadMutation:
		return c.Thread.mutate(ctx, m)
	case *ThreadTagMutation:
		return c.ThreadTag.mutate(ctx, m)
	case *ThreadTaggingMutation:
		return c.ThreadTagging.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserBoardLikeMutation:
		return c.UserBoardLike.mutate(ctx, m)
	case *UserBoardSubscriptionMutation:
		return c.UserBoardSubscription.mutate(ctx, m)
	case *UserCommentLikeMutation:
		return c.UserCommentLike.mutate(ctx, m)
	case *UserCommentSubscriptionMutation:
		return c.UserCommentSubscription.mutate(ctx, m)
	case *UserThreadLikeMutation:
		return c.UserThreadLike.mutate(ctx, m)
	case *UserThreadSubscriptionMutation:
		return c.UserThreadSubscription.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AdminUserClient is a client for the AdminUser schema.
type AdminUserClient struct {
	config
}

// NewAdminUserClient returns a client for the AdminUser from the given config.
func NewAdminUserClient(c config) *AdminUserClient {
	return &AdminUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adminuser.Hooks(f(g(h())))`.
func (c *AdminUserClient) Use(hooks ...Hook) {
	c.hooks.AdminUser = append(c.hooks.AdminUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `adminuser.Intercept(f(g(h())))`.
func (c *AdminUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AdminUser = append(c.inters.AdminUser, interceptors...)
}

// Create returns a builder for creating a AdminUser entity.
func (c *AdminUserClient) Create() *AdminUserCreate {
	mutation := newAdminUserMutation(c.config, OpCreate)
	return &AdminUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AdminUser entities.
func (c *AdminUserClient) CreateBulk(builders ...*AdminUserCreate) *AdminUserCreateBulk {
	return &AdminUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AdminUserClient) MapCreateBulk(slice any, setFunc func(*AdminUserCreate, int)) *AdminUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AdminUserCreateBulk{err: fmt.Errorf("calling to AdminUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AdminUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AdminUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AdminUser.
func (c *AdminUserClient) Update() *AdminUserUpdate {
	mutation := newAdminUserMutation(c.config, OpUpdate)
	return &AdminUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdminUserClient) UpdateOne(au *AdminUser) *AdminUserUpdateOne {
	mutation := newAdminUserMutation(c.config, OpUpdateOne, withAdminUser(au))
	return &AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdminUserClient) UpdateOneID(id int) *AdminUserUpdateOne {
	mutation := newAdminUserMutation(c.config, OpUpdateOne, withAdminUserID(id))
	return &AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AdminUser.
func (c *AdminUserClient) Delete() *AdminUserDelete {
	mutation := newAdminUserMutation(c.config, OpDelete)
	return &AdminUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AdminUserClient) DeleteOne(au *AdminUser) *AdminUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AdminUserClient) DeleteOneID(id int) *AdminUserDeleteOne {
	builder := c.Delete().Where(adminuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdminUserDeleteOne{builder}
}

// Query returns a query builder for AdminUser.
func (c *AdminUserClient) Query() *AdminUserQuery {
	return &AdminUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAdminUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AdminUser entity by its id.
func (c *AdminUserClient) Get(ctx context.Context, id int) (*AdminUser, error) {
	return c.Query().Where(adminuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdminUserClient) GetX(ctx context.Context, id int) *AdminUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AdminUserClient) Hooks() []Hook {
	return c.hooks.AdminUser
}

// Interceptors returns the client interceptors.
func (c *AdminUserClient) Interceptors() []Interceptor {
	return c.inters.AdminUser
}

func (c *AdminUserClient) mutate(ctx context.Context, m *AdminUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AdminUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AdminUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AdminUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AdminUser mutation op: %q", m.Op())
	}
}

// BoardClient is a client for the Board schema.
type BoardClient struct {
	config
}

// NewBoardClient returns a client for the Board from the given config.
func NewBoardClient(c config) *BoardClient {
	return &BoardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `board.Hooks(f(g(h())))`.
func (c *BoardClient) Use(hooks ...Hook) {
	c.hooks.Board = append(c.hooks.Board, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `board.Intercept(f(g(h())))`.
func (c *BoardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Board = append(c.inters.Board, interceptors...)
}

// Create returns a builder for creating a Board entity.
func (c *BoardClient) Create() *BoardCreate {
	mutation := newBoardMutation(c.config, OpCreate)
	return &BoardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Board entities.
func (c *BoardClient) CreateBulk(builders ...*BoardCreate) *BoardCreateBulk {
	return &BoardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BoardClient) MapCreateBulk(slice any, setFunc func(*BoardCreate, int)) *BoardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BoardCreateBulk{err: fmt.Errorf("calling to BoardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BoardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BoardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Board.
func (c *BoardClient) Update() *BoardUpdate {
	mutation := newBoardMutation(c.config, OpUpdate)
	return &BoardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BoardClient) UpdateOne(b *Board) *BoardUpdateOne {
	mutation := newBoardMutation(c.config, OpUpdateOne, withBoard(b))
	return &BoardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BoardClient) UpdateOneID(id int) *BoardUpdateOne {
	mutation := newBoardMutation(c.config, OpUpdateOne, withBoardID(id))
	return &BoardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Board.
func (c *BoardClient) Delete() *BoardDelete {
	mutation := newBoardMutation(c.config, OpDelete)
	return &BoardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BoardClient) DeleteOne(b *Board) *BoardDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BoardClient) DeleteOneID(id int) *BoardDeleteOne {
	builder := c.Delete().Where(board.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BoardDeleteOne{builder}
}

// Query returns a query builder for Board.
func (c *BoardClient) Query() *BoardQuery {
	return &BoardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBoard},
		inters: c.Interceptors(),
	}
}

// Get returns a Board entity by its id.
func (c *BoardClient) Get(ctx context.Context, id int) (*Board, error) {
	return c.Query().Where(board.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BoardClient) GetX(ctx context.Context, id int) *Board {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLikedUsers queries the liked_users edge of a Board.
func (c *BoardClient) QueryLikedUsers(b *Board) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(board.Table, board.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, board.LikedUsersTable, board.LikedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribedUsers queries the subscribed_users edge of a Board.
func (c *BoardClient) QuerySubscribedUsers(b *Board) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(board.Table, board.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, board.SubscribedUsersTable, board.SubscribedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreads queries the threads edge of a Board.
func (c *BoardClient) QueryThreads(b *Board) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(board.Table, board.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, board.ThreadsTable, board.ThreadsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserBoardLike queries the user_board_like edge of a Board.
func (c *BoardClient) QueryUserBoardLike(b *Board) *UserBoardSubscriptionQuery {
	query := (&UserBoardSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(board.Table, board.FieldID, id),
			sqlgraph.To(userboardsubscription.Table, userboardsubscription.BoardColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, board.UserBoardLikeTable, board.UserBoardLikeColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserBoardSubscription queries the user_board_subscription edge of a Board.
func (c *BoardClient) QueryUserBoardSubscription(b *Board) *UserBoardLikeQuery {
	query := (&UserBoardLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(board.Table, board.FieldID, id),
			sqlgraph.To(userboardlike.Table, userboardlike.BoardColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, board.UserBoardSubscriptionTable, board.UserBoardSubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BoardClient) Hooks() []Hook {
	return c.hooks.Board
}

// Interceptors returns the client interceptors.
func (c *BoardClient) Interceptors() []Interceptor {
	return c.inters.Board
}

func (c *BoardClient) mutate(ctx context.Context, m *BoardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BoardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BoardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BoardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BoardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Board mutation op: %q", m.Op())
	}
}

// CommentClient is a client for the Comment schema.
type CommentClient struct {
	config
}

// NewCommentClient returns a client for the Comment from the given config.
func NewCommentClient(c config) *CommentClient {
	return &CommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `comment.Hooks(f(g(h())))`.
func (c *CommentClient) Use(hooks ...Hook) {
	c.hooks.Comment = append(c.hooks.Comment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `comment.Intercept(f(g(h())))`.
func (c *CommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Comment = append(c.inters.Comment, interceptors...)
}

// Create returns a builder for creating a Comment entity.
func (c *CommentClient) Create() *CommentCreate {
	mutation := newCommentMutation(c.config, OpCreate)
	return &CommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Comment entities.
func (c *CommentClient) CreateBulk(builders ...*CommentCreate) *CommentCreateBulk {
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommentClient) MapCreateBulk(slice any, setFunc func(*CommentCreate, int)) *CommentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommentCreateBulk{err: fmt.Errorf("calling to CommentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Comment.
func (c *CommentClient) Update() *CommentUpdate {
	mutation := newCommentMutation(c.config, OpUpdate)
	return &CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentClient) UpdateOne(co *Comment) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withComment(co))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentClient) UpdateOneID(id int) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withCommentID(id))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Comment.
func (c *CommentClient) Delete() *CommentDelete {
	mutation := newCommentMutation(c.config, OpDelete)
	return &CommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentClient) DeleteOne(co *Comment) *CommentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentClient) DeleteOneID(id int) *CommentDeleteOne {
	builder := c.Delete().Where(comment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentDeleteOne{builder}
}

// Query returns a query builder for Comment.
func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComment},
		inters: c.Interceptors(),
	}
}

// Get returns a Comment entity by its id.
func (c *CommentClient) Get(ctx context.Context, id int) (*Comment, error) {
	return c.Query().Where(comment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentClient) GetX(ctx context.Context, id int) *Comment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryThread queries the thread edge of a Comment.
func (c *CommentClient) QueryThread(co *Comment) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.ThreadTable, comment.ThreadColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthor queries the author edge of a Comment.
func (c *CommentClient) QueryAuthor(co *Comment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.AuthorTable, comment.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentComment queries the parent_comment edge of a Comment.
func (c *CommentClient) QueryParentComment(co *Comment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.ParentCommentTable, comment.ParentCommentColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReplies queries the replies edge of a Comment.
func (c *CommentClient) QueryReplies(co *Comment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, comment.RepliesTable, comment.RepliesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommentAttachments queries the comment_attachments edge of a Comment.
func (c *CommentClient) QueryCommentAttachments(co *Comment) *CommentAttachmentQuery {
	query := (&CommentAttachmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(commentattachment.Table, commentattachment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, comment.CommentAttachmentsTable, comment.CommentAttachmentsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedUsers queries the liked_users edge of a Comment.
func (c *CommentClient) QueryLikedUsers(co *Comment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, comment.LikedUsersTable, comment.LikedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribedUsers queries the subscribed_users edge of a Comment.
func (c *CommentClient) QuerySubscribedUsers(co *Comment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, comment.SubscribedUsersTable, comment.SubscribedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserCommentLike queries the user_comment_like edge of a Comment.
func (c *CommentClient) QueryUserCommentLike(co *Comment) *UserCommentLikeQuery {
	query := (&UserCommentLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(usercommentlike.Table, usercommentlike.CommentColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, comment.UserCommentLikeTable, comment.UserCommentLikeColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserCommentSubscription queries the user_comment_subscription edge of a Comment.
func (c *CommentClient) QueryUserCommentSubscription(co *Comment) *UserCommentSubscriptionQuery {
	query := (&UserCommentSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(usercommentsubscription.Table, usercommentsubscription.CommentColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, comment.UserCommentSubscriptionTable, comment.UserCommentSubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommentClient) Hooks() []Hook {
	return c.hooks.Comment
}

// Interceptors returns the client interceptors.
func (c *CommentClient) Interceptors() []Interceptor {
	return c.inters.Comment
}

func (c *CommentClient) mutate(ctx context.Context, m *CommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Comment mutation op: %q", m.Op())
	}
}

// CommentAttachmentClient is a client for the CommentAttachment schema.
type CommentAttachmentClient struct {
	config
}

// NewCommentAttachmentClient returns a client for the CommentAttachment from the given config.
func NewCommentAttachmentClient(c config) *CommentAttachmentClient {
	return &CommentAttachmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `commentattachment.Hooks(f(g(h())))`.
func (c *CommentAttachmentClient) Use(hooks ...Hook) {
	c.hooks.CommentAttachment = append(c.hooks.CommentAttachment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `commentattachment.Intercept(f(g(h())))`.
func (c *CommentAttachmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.CommentAttachment = append(c.inters.CommentAttachment, interceptors...)
}

// Create returns a builder for creating a CommentAttachment entity.
func (c *CommentAttachmentClient) Create() *CommentAttachmentCreate {
	mutation := newCommentAttachmentMutation(c.config, OpCreate)
	return &CommentAttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CommentAttachment entities.
func (c *CommentAttachmentClient) CreateBulk(builders ...*CommentAttachmentCreate) *CommentAttachmentCreateBulk {
	return &CommentAttachmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommentAttachmentClient) MapCreateBulk(slice any, setFunc func(*CommentAttachmentCreate, int)) *CommentAttachmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommentAttachmentCreateBulk{err: fmt.Errorf("calling to CommentAttachmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommentAttachmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommentAttachmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CommentAttachment.
func (c *CommentAttachmentClient) Update() *CommentAttachmentUpdate {
	mutation := newCommentAttachmentMutation(c.config, OpUpdate)
	return &CommentAttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentAttachmentClient) UpdateOne(ca *CommentAttachment) *CommentAttachmentUpdateOne {
	mutation := newCommentAttachmentMutation(c.config, OpUpdateOne, withCommentAttachment(ca))
	return &CommentAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentAttachmentClient) UpdateOneID(id int) *CommentAttachmentUpdateOne {
	mutation := newCommentAttachmentMutation(c.config, OpUpdateOne, withCommentAttachmentID(id))
	return &CommentAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CommentAttachment.
func (c *CommentAttachmentClient) Delete() *CommentAttachmentDelete {
	mutation := newCommentAttachmentMutation(c.config, OpDelete)
	return &CommentAttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentAttachmentClient) DeleteOne(ca *CommentAttachment) *CommentAttachmentDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentAttachmentClient) DeleteOneID(id int) *CommentAttachmentDeleteOne {
	builder := c.Delete().Where(commentattachment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentAttachmentDeleteOne{builder}
}

// Query returns a query builder for CommentAttachment.
func (c *CommentAttachmentClient) Query() *CommentAttachmentQuery {
	return &CommentAttachmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCommentAttachment},
		inters: c.Interceptors(),
	}
}

// Get returns a CommentAttachment entity by its id.
func (c *CommentAttachmentClient) Get(ctx context.Context, id int) (*CommentAttachment, error) {
	return c.Query().Where(commentattachment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentAttachmentClient) GetX(ctx context.Context, id int) *CommentAttachment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComment queries the comment edge of a CommentAttachment.
func (c *CommentAttachmentClient) QueryComment(ca *CommentAttachment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(commentattachment.Table, commentattachment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, commentattachment.CommentTable, commentattachment.CommentColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommentAttachmentClient) Hooks() []Hook {
	return c.hooks.CommentAttachment
}

// Interceptors returns the client interceptors.
func (c *CommentAttachmentClient) Interceptors() []Interceptor {
	return c.inters.CommentAttachment
}

func (c *CommentAttachmentClient) mutate(ctx context.Context, m *CommentAttachmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentAttachmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentAttachmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentAttachmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentAttachmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CommentAttachment mutation op: %q", m.Op())
	}
}

// ThreadClient is a client for the Thread schema.
type ThreadClient struct {
	config
}

// NewThreadClient returns a client for the Thread from the given config.
func NewThreadClient(c config) *ThreadClient {
	return &ThreadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `thread.Hooks(f(g(h())))`.
func (c *ThreadClient) Use(hooks ...Hook) {
	c.hooks.Thread = append(c.hooks.Thread, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `thread.Intercept(f(g(h())))`.
func (c *ThreadClient) Intercept(interceptors ...Interceptor) {
	c.inters.Thread = append(c.inters.Thread, interceptors...)
}

// Create returns a builder for creating a Thread entity.
func (c *ThreadClient) Create() *ThreadCreate {
	mutation := newThreadMutation(c.config, OpCreate)
	return &ThreadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Thread entities.
func (c *ThreadClient) CreateBulk(builders ...*ThreadCreate) *ThreadCreateBulk {
	return &ThreadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadClient) MapCreateBulk(slice any, setFunc func(*ThreadCreate, int)) *ThreadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadCreateBulk{err: fmt.Errorf("calling to ThreadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Thread.
func (c *ThreadClient) Update() *ThreadUpdate {
	mutation := newThreadMutation(c.config, OpUpdate)
	return &ThreadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadClient) UpdateOne(t *Thread) *ThreadUpdateOne {
	mutation := newThreadMutation(c.config, OpUpdateOne, withThread(t))
	return &ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ThreadClient) UpdateOneID(id int) *ThreadUpdateOne {
	mutation := newThreadMutation(c.config, OpUpdateOne, withThreadID(id))
	return &ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Thread.
func (c *ThreadClient) Delete() *ThreadDelete {
	mutation := newThreadMutation(c.config, OpDelete)
	return &ThreadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ThreadClient) DeleteOne(t *Thread) *ThreadDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ThreadClient) DeleteOneID(id int) *ThreadDeleteOne {
	builder := c.Delete().Where(thread.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ThreadDeleteOne{builder}
}

// Query returns a query builder for Thread.
func (c *ThreadClient) Query() *ThreadQuery {
	return &ThreadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThread},
		inters: c.Interceptors(),
	}
}

// Get returns a Thread entity by its id.
func (c *ThreadClient) Get(ctx context.Context, id int) (*Thread, error) {
	return c.Query().Where(thread.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ThreadClient) GetX(ctx context.Context, id int) *Thread {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBoard queries the board edge of a Thread.
func (c *ThreadClient) QueryBoard(t *Thread) *BoardQuery {
	query := (&BoardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(board.Table, board.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, thread.BoardTable, thread.BoardColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Thread.
func (c *ThreadClient) QueryOwner(t *Thread) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, thread.OwnerTable, thread.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Thread.
func (c *ThreadClient) QueryComments(t *Thread) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, thread.CommentsTable, thread.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Thread.
func (c *ThreadClient) QueryTags(t *Thread) *ThreadTagQuery {
	query := (&ThreadTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(threadtag.Table, threadtag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, thread.TagsTable, thread.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedUsers queries the liked_users edge of a Thread.
func (c *ThreadClient) QueryLikedUsers(t *Thread) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, thread.LikedUsersTable, thread.LikedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribedUsers queries the subscribed_users edge of a Thread.
func (c *ThreadClient) QuerySubscribedUsers(t *Thread) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, thread.SubscribedUsersTable, thread.SubscribedUsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreadTaggings queries the thread_taggings edge of a Thread.
func (c *ThreadClient) QueryThreadTaggings(t *Thread) *ThreadTaggingQuery {
	query := (&ThreadTaggingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(threadtagging.Table, threadtagging.ThreadColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, thread.ThreadTaggingsTable, thread.ThreadTaggingsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserThreadLike queries the user_thread_like edge of a Thread.
func (c *ThreadClient) QueryUserThreadLike(t *Thread) *UserThreadLikeQuery {
	query := (&UserThreadLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(userthreadlike.Table, userthreadlike.ThreadColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, thread.UserThreadLikeTable, thread.UserThreadLikeColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserThreadSubscription queries the user_thread_subscription edge of a Thread.
func (c *ThreadClient) QueryUserThreadSubscription(t *Thread) *UserThreadSubscriptionQuery {
	query := (&UserThreadSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(thread.Table, thread.FieldID, id),
			sqlgraph.To(userthreadsubscription.Table, userthreadsubscription.ThreadColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, thread.UserThreadSubscriptionTable, thread.UserThreadSubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ThreadClient) Hooks() []Hook {
	return c.hooks.Thread
}

// Interceptors returns the client interceptors.
func (c *ThreadClient) Interceptors() []Interceptor {
	return c.inters.Thread
}

func (c *ThreadClient) mutate(ctx context.Context, m *ThreadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Thread mutation op: %q", m.Op())
	}
}

// ThreadTagClient is a client for the ThreadTag schema.
type ThreadTagClient struct {
	config
}

// NewThreadTagClient returns a client for the ThreadTag from the given config.
func NewThreadTagClient(c config) *ThreadTagClient {
	return &ThreadTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `threadtag.Hooks(f(g(h())))`.
func (c *ThreadTagClient) Use(hooks ...Hook) {
	c.hooks.ThreadTag = append(c.hooks.ThreadTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `threadtag.Intercept(f(g(h())))`.
func (c *ThreadTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.ThreadTag = append(c.inters.ThreadTag, interceptors...)
}

// Create returns a builder for creating a ThreadTag entity.
func (c *ThreadTagClient) Create() *ThreadTagCreate {
	mutation := newThreadTagMutation(c.config, OpCreate)
	return &ThreadTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ThreadTag entities.
func (c *ThreadTagClient) CreateBulk(builders ...*ThreadTagCreate) *ThreadTagCreateBulk {
	return &ThreadTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadTagClient) MapCreateBulk(slice any, setFunc func(*ThreadTagCreate, int)) *ThreadTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadTagCreateBulk{err: fmt.Errorf("calling to ThreadTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ThreadTag.
func (c *ThreadTagClient) Update() *ThreadTagUpdate {
	mutation := newThreadTagMutation(c.config, OpUpdate)
	return &ThreadTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadTagClient) UpdateOne(tt *ThreadTag) *ThreadTagUpdateOne {
	mutation := newThreadTagMutation(c.config, OpUpdateOne, withThreadTag(tt))
	return &ThreadTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ThreadTagClient) UpdateOneID(id int) *ThreadTagUpdateOne {
	mutation := newThreadTagMutation(c.config, OpUpdateOne, withThreadTagID(id))
	return &ThreadTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ThreadTag.
func (c *ThreadTagClient) Delete() *ThreadTagDelete {
	mutation := newThreadTagMutation(c.config, OpDelete)
	return &ThreadTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ThreadTagClient) DeleteOne(tt *ThreadTag) *ThreadTagDeleteOne {
	return c.DeleteOneID(tt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ThreadTagClient) DeleteOneID(id int) *ThreadTagDeleteOne {
	builder := c.Delete().Where(threadtag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ThreadTagDeleteOne{builder}
}

// Query returns a query builder for ThreadTag.
func (c *ThreadTagClient) Query() *ThreadTagQuery {
	return &ThreadTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThreadTag},
		inters: c.Interceptors(),
	}
}

// Get returns a ThreadTag entity by its id.
func (c *ThreadTagClient) Get(ctx context.Context, id int) (*ThreadTag, error) {
	return c.Query().Where(threadtag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ThreadTagClient) GetX(ctx context.Context, id int) *ThreadTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryThreads queries the threads edge of a ThreadTag.
func (c *ThreadTagClient) QueryThreads(tt *ThreadTag) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadtag.Table, threadtag.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, threadtag.ThreadsTable, threadtag.ThreadsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreadTaggings queries the thread_taggings edge of a ThreadTag.
func (c *ThreadTagClient) QueryThreadTaggings(tt *ThreadTag) *ThreadTaggingQuery {
	query := (&ThreadTaggingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(threadtag.Table, threadtag.FieldID, id),
			sqlgraph.To(threadtagging.Table, threadtagging.TagColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, threadtag.ThreadTaggingsTable, threadtag.ThreadTaggingsColumn),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ThreadTagClient) Hooks() []Hook {
	return c.hooks.ThreadTag
}

// Interceptors returns the client interceptors.
func (c *ThreadTagClient) Interceptors() []Interceptor {
	return c.inters.ThreadTag
}

func (c *ThreadTagClient) mutate(ctx context.Context, m *ThreadTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ThreadTag mutation op: %q", m.Op())
	}
}

// ThreadTaggingClient is a client for the ThreadTagging schema.
type ThreadTaggingClient struct {
	config
}

// NewThreadTaggingClient returns a client for the ThreadTagging from the given config.
func NewThreadTaggingClient(c config) *ThreadTaggingClient {
	return &ThreadTaggingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `threadtagging.Hooks(f(g(h())))`.
func (c *ThreadTaggingClient) Use(hooks ...Hook) {
	c.hooks.ThreadTagging = append(c.hooks.ThreadTagging, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `threadtagging.Intercept(f(g(h())))`.
func (c *ThreadTaggingClient) Intercept(interceptors ...Interceptor) {
	c.inters.ThreadTagging = append(c.inters.ThreadTagging, interceptors...)
}

// Create returns a builder for creating a ThreadTagging entity.
func (c *ThreadTaggingClient) Create() *ThreadTaggingCreate {
	mutation := newThreadTaggingMutation(c.config, OpCreate)
	return &ThreadTaggingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ThreadTagging entities.
func (c *ThreadTaggingClient) CreateBulk(builders ...*ThreadTaggingCreate) *ThreadTaggingCreateBulk {
	return &ThreadTaggingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ThreadTaggingClient) MapCreateBulk(slice any, setFunc func(*ThreadTaggingCreate, int)) *ThreadTaggingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ThreadTaggingCreateBulk{err: fmt.Errorf("calling to ThreadTaggingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ThreadTaggingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ThreadTaggingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ThreadTagging.
func (c *ThreadTaggingClient) Update() *ThreadTaggingUpdate {
	mutation := newThreadTaggingMutation(c.config, OpUpdate)
	return &ThreadTaggingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ThreadTaggingClient) UpdateOne(tt *ThreadTagging) *ThreadTaggingUpdateOne {
	mutation := newThreadTaggingMutation(c.config, OpUpdateOne)
	mutation.thread = &tt.ThreadId
	mutation.tag = &tt.TagId
	return &ThreadTaggingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ThreadTagging.
func (c *ThreadTaggingClient) Delete() *ThreadTaggingDelete {
	mutation := newThreadTaggingMutation(c.config, OpDelete)
	return &ThreadTaggingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for ThreadTagging.
func (c *ThreadTaggingClient) Query() *ThreadTaggingQuery {
	return &ThreadTaggingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeThreadTagging},
		inters: c.Interceptors(),
	}
}

// QueryThread queries the thread edge of a ThreadTagging.
func (c *ThreadTaggingClient) QueryThread(tt *ThreadTagging) *ThreadQuery {
	return c.Query().
		Where(threadtagging.ThreadId(tt.ThreadId), threadtagging.TagId(tt.TagId)).
		QueryThread()
}

// QueryTag queries the tag edge of a ThreadTagging.
func (c *ThreadTaggingClient) QueryTag(tt *ThreadTagging) *ThreadTagQuery {
	return c.Query().
		Where(threadtagging.ThreadId(tt.ThreadId), threadtagging.TagId(tt.TagId)).
		QueryTag()
}

// Hooks returns the client hooks.
func (c *ThreadTaggingClient) Hooks() []Hook {
	return c.hooks.ThreadTagging
}

// Interceptors returns the client interceptors.
func (c *ThreadTaggingClient) Interceptors() []Interceptor {
	return c.inters.ThreadTagging
}

func (c *ThreadTaggingClient) mutate(ctx context.Context, m *ThreadTaggingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ThreadTaggingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ThreadTaggingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ThreadTaggingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ThreadTaggingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ThreadTagging mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBoards queries the boards edge of a User.
func (c *UserClient) QueryBoards(u *User) *BoardQuery {
	query := (&BoardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(board.Table, board.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BoardsTable, user.BoardsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryThreads queries the threads edge of a User.
func (c *UserClient) QueryThreads(u *User) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ThreadsTable, user.ThreadsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a User.
func (c *UserClient) QueryComments(u *User) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CommentsTable, user.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedBoards queries the liked_boards edge of a User.
func (c *UserClient) QueryLikedBoards(u *User) *BoardQuery {
	query := (&BoardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(board.Table, board.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.LikedBoardsTable, user.LikedBoardsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedThreads queries the liked_threads edge of a User.
func (c *UserClient) QueryLikedThreads(u *User) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.LikedThreadsTable, user.LikedThreadsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLikedComments queries the liked_comments edge of a User.
func (c *UserClient) QueryLikedComments(u *User) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.LikedCommentsTable, user.LikedCommentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribedBoards queries the subscribed_boards edge of a User.
func (c *UserClient) QuerySubscribedBoards(u *User) *BoardQuery {
	query := (&BoardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(board.Table, board.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.SubscribedBoardsTable, user.SubscribedBoardsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribedThreads queries the subscribed_threads edge of a User.
func (c *UserClient) QuerySubscribedThreads(u *User) *ThreadQuery {
	query := (&ThreadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(thread.Table, thread.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.SubscribedThreadsTable, user.SubscribedThreadsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscribedComments queries the subscribed_comments edge of a User.
func (c *UserClient) QuerySubscribedComments(u *User) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.SubscribedCommentsTable, user.SubscribedCommentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserBoardLike queries the user_board_like edge of a User.
func (c *UserClient) QueryUserBoardLike(u *User) *UserBoardLikeQuery {
	query := (&UserBoardLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userboardlike.Table, userboardlike.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserBoardLikeTable, user.UserBoardLikeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserThreadLike queries the user_thread_like edge of a User.
func (c *UserClient) QueryUserThreadLike(u *User) *UserThreadLikeQuery {
	query := (&UserThreadLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userthreadlike.Table, userthreadlike.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserThreadLikeTable, user.UserThreadLikeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserCommentLike queries the user_comment_like edge of a User.
func (c *UserClient) QueryUserCommentLike(u *User) *UserCommentLikeQuery {
	query := (&UserCommentLikeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usercommentlike.Table, usercommentlike.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserCommentLikeTable, user.UserCommentLikeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserBoardSubscription queries the user_board_subscription edge of a User.
func (c *UserClient) QueryUserBoardSubscription(u *User) *UserBoardSubscriptionQuery {
	query := (&UserBoardSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userboardsubscription.Table, userboardsubscription.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserBoardSubscriptionTable, user.UserBoardSubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserThreadSubscription queries the user_thread_subscription edge of a User.
func (c *UserClient) QueryUserThreadSubscription(u *User) *UserThreadSubscriptionQuery {
	query := (&UserThreadSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userthreadsubscription.Table, userthreadsubscription.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserThreadSubscriptionTable, user.UserThreadSubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserCommentSubscription queries the user_comment_subscription edge of a User.
func (c *UserClient) QueryUserCommentSubscription(u *User) *UserCommentSubscriptionQuery {
	query := (&UserCommentSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usercommentsubscription.Table, usercommentsubscription.UserColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserCommentSubscriptionTable, user.UserCommentSubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserBoardLikeClient is a client for the UserBoardLike schema.
type UserBoardLikeClient struct {
	config
}

// NewUserBoardLikeClient returns a client for the UserBoardLike from the given config.
func NewUserBoardLikeClient(c config) *UserBoardLikeClient {
	return &UserBoardLikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userboardlike.Hooks(f(g(h())))`.
func (c *UserBoardLikeClient) Use(hooks ...Hook) {
	c.hooks.UserBoardLike = append(c.hooks.UserBoardLike, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userboardlike.Intercept(f(g(h())))`.
func (c *UserBoardLikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBoardLike = append(c.inters.UserBoardLike, interceptors...)
}

// Create returns a builder for creating a UserBoardLike entity.
func (c *UserBoardLikeClient) Create() *UserBoardLikeCreate {
	mutation := newUserBoardLikeMutation(c.config, OpCreate)
	return &UserBoardLikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBoardLike entities.
func (c *UserBoardLikeClient) CreateBulk(builders ...*UserBoardLikeCreate) *UserBoardLikeCreateBulk {
	return &UserBoardLikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserBoardLikeClient) MapCreateBulk(slice any, setFunc func(*UserBoardLikeCreate, int)) *UserBoardLikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserBoardLikeCreateBulk{err: fmt.Errorf("calling to UserBoardLikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserBoardLikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserBoardLikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBoardLike.
func (c *UserBoardLikeClient) Update() *UserBoardLikeUpdate {
	mutation := newUserBoardLikeMutation(c.config, OpUpdate)
	return &UserBoardLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBoardLikeClient) UpdateOne(ubl *UserBoardLike) *UserBoardLikeUpdateOne {
	mutation := newUserBoardLikeMutation(c.config, OpUpdateOne)
	mutation.user = &ubl.UserId
	mutation.board = &ubl.BoardId
	return &UserBoardLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBoardLike.
func (c *UserBoardLikeClient) Delete() *UserBoardLikeDelete {
	mutation := newUserBoardLikeMutation(c.config, OpDelete)
	return &UserBoardLikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UserBoardLike.
func (c *UserBoardLikeClient) Query() *UserBoardLikeQuery {
	return &UserBoardLikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBoardLike},
		inters: c.Interceptors(),
	}
}

// QueryUser queries the user edge of a UserBoardLike.
func (c *UserBoardLikeClient) QueryUser(ubl *UserBoardLike) *UserQuery {
	return c.Query().
		Where(userboardlike.UserId(ubl.UserId), userboardlike.BoardId(ubl.BoardId)).
		QueryUser()
}

// QueryBoard queries the board edge of a UserBoardLike.
func (c *UserBoardLikeClient) QueryBoard(ubl *UserBoardLike) *BoardQuery {
	return c.Query().
		Where(userboardlike.UserId(ubl.UserId), userboardlike.BoardId(ubl.BoardId)).
		QueryBoard()
}

// Hooks returns the client hooks.
func (c *UserBoardLikeClient) Hooks() []Hook {
	return c.hooks.UserBoardLike
}

// Interceptors returns the client interceptors.
func (c *UserBoardLikeClient) Interceptors() []Interceptor {
	return c.inters.UserBoardLike
}

func (c *UserBoardLikeClient) mutate(ctx context.Context, m *UserBoardLikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBoardLikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBoardLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBoardLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBoardLikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserBoardLike mutation op: %q", m.Op())
	}
}

// UserBoardSubscriptionClient is a client for the UserBoardSubscription schema.
type UserBoardSubscriptionClient struct {
	config
}

// NewUserBoardSubscriptionClient returns a client for the UserBoardSubscription from the given config.
func NewUserBoardSubscriptionClient(c config) *UserBoardSubscriptionClient {
	return &UserBoardSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userboardsubscription.Hooks(f(g(h())))`.
func (c *UserBoardSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.UserBoardSubscription = append(c.hooks.UserBoardSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userboardsubscription.Intercept(f(g(h())))`.
func (c *UserBoardSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBoardSubscription = append(c.inters.UserBoardSubscription, interceptors...)
}

// Create returns a builder for creating a UserBoardSubscription entity.
func (c *UserBoardSubscriptionClient) Create() *UserBoardSubscriptionCreate {
	mutation := newUserBoardSubscriptionMutation(c.config, OpCreate)
	return &UserBoardSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBoardSubscription entities.
func (c *UserBoardSubscriptionClient) CreateBulk(builders ...*UserBoardSubscriptionCreate) *UserBoardSubscriptionCreateBulk {
	return &UserBoardSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserBoardSubscriptionClient) MapCreateBulk(slice any, setFunc func(*UserBoardSubscriptionCreate, int)) *UserBoardSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserBoardSubscriptionCreateBulk{err: fmt.Errorf("calling to UserBoardSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserBoardSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserBoardSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBoardSubscription.
func (c *UserBoardSubscriptionClient) Update() *UserBoardSubscriptionUpdate {
	mutation := newUserBoardSubscriptionMutation(c.config, OpUpdate)
	return &UserBoardSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBoardSubscriptionClient) UpdateOne(ubs *UserBoardSubscription) *UserBoardSubscriptionUpdateOne {
	mutation := newUserBoardSubscriptionMutation(c.config, OpUpdateOne)
	mutation.user = &ubs.UserId
	mutation.board = &ubs.BoardId
	return &UserBoardSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBoardSubscription.
func (c *UserBoardSubscriptionClient) Delete() *UserBoardSubscriptionDelete {
	mutation := newUserBoardSubscriptionMutation(c.config, OpDelete)
	return &UserBoardSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UserBoardSubscription.
func (c *UserBoardSubscriptionClient) Query() *UserBoardSubscriptionQuery {
	return &UserBoardSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBoardSubscription},
		inters: c.Interceptors(),
	}
}

// QueryUser queries the user edge of a UserBoardSubscription.
func (c *UserBoardSubscriptionClient) QueryUser(ubs *UserBoardSubscription) *UserQuery {
	return c.Query().
		Where(userboardsubscription.UserId(ubs.UserId), userboardsubscription.BoardId(ubs.BoardId)).
		QueryUser()
}

// QueryBoard queries the board edge of a UserBoardSubscription.
func (c *UserBoardSubscriptionClient) QueryBoard(ubs *UserBoardSubscription) *BoardQuery {
	return c.Query().
		Where(userboardsubscription.UserId(ubs.UserId), userboardsubscription.BoardId(ubs.BoardId)).
		QueryBoard()
}

// Hooks returns the client hooks.
func (c *UserBoardSubscriptionClient) Hooks() []Hook {
	return c.hooks.UserBoardSubscription
}

// Interceptors returns the client interceptors.
func (c *UserBoardSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.UserBoardSubscription
}

func (c *UserBoardSubscriptionClient) mutate(ctx context.Context, m *UserBoardSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBoardSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBoardSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBoardSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBoardSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserBoardSubscription mutation op: %q", m.Op())
	}
}

// UserCommentLikeClient is a client for the UserCommentLike schema.
type UserCommentLikeClient struct {
	config
}

// NewUserCommentLikeClient returns a client for the UserCommentLike from the given config.
func NewUserCommentLikeClient(c config) *UserCommentLikeClient {
	return &UserCommentLikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercommentlike.Hooks(f(g(h())))`.
func (c *UserCommentLikeClient) Use(hooks ...Hook) {
	c.hooks.UserCommentLike = append(c.hooks.UserCommentLike, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercommentlike.Intercept(f(g(h())))`.
func (c *UserCommentLikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserCommentLike = append(c.inters.UserCommentLike, interceptors...)
}

// Create returns a builder for creating a UserCommentLike entity.
func (c *UserCommentLikeClient) Create() *UserCommentLikeCreate {
	mutation := newUserCommentLikeMutation(c.config, OpCreate)
	return &UserCommentLikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserCommentLike entities.
func (c *UserCommentLikeClient) CreateBulk(builders ...*UserCommentLikeCreate) *UserCommentLikeCreateBulk {
	return &UserCommentLikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserCommentLikeClient) MapCreateBulk(slice any, setFunc func(*UserCommentLikeCreate, int)) *UserCommentLikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCommentLikeCreateBulk{err: fmt.Errorf("calling to UserCommentLikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCommentLikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCommentLikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserCommentLike.
func (c *UserCommentLikeClient) Update() *UserCommentLikeUpdate {
	mutation := newUserCommentLikeMutation(c.config, OpUpdate)
	return &UserCommentLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserCommentLikeClient) UpdateOne(ucl *UserCommentLike) *UserCommentLikeUpdateOne {
	mutation := newUserCommentLikeMutation(c.config, OpUpdateOne)
	mutation.user = &ucl.UserId
	mutation.comment = &ucl.CommentId
	return &UserCommentLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserCommentLike.
func (c *UserCommentLikeClient) Delete() *UserCommentLikeDelete {
	mutation := newUserCommentLikeMutation(c.config, OpDelete)
	return &UserCommentLikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UserCommentLike.
func (c *UserCommentLikeClient) Query() *UserCommentLikeQuery {
	return &UserCommentLikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserCommentLike},
		inters: c.Interceptors(),
	}
}

// QueryUser queries the user edge of a UserCommentLike.
func (c *UserCommentLikeClient) QueryUser(ucl *UserCommentLike) *UserQuery {
	return c.Query().
		Where(usercommentlike.UserId(ucl.UserId), usercommentlike.CommentId(ucl.CommentId)).
		QueryUser()
}

// QueryComment queries the comment edge of a UserCommentLike.
func (c *UserCommentLikeClient) QueryComment(ucl *UserCommentLike) *CommentQuery {
	return c.Query().
		Where(usercommentlike.UserId(ucl.UserId), usercommentlike.CommentId(ucl.CommentId)).
		QueryComment()
}

// Hooks returns the client hooks.
func (c *UserCommentLikeClient) Hooks() []Hook {
	return c.hooks.UserCommentLike
}

// Interceptors returns the client interceptors.
func (c *UserCommentLikeClient) Interceptors() []Interceptor {
	return c.inters.UserCommentLike
}

func (c *UserCommentLikeClient) mutate(ctx context.Context, m *UserCommentLikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCommentLikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserCommentLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserCommentLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserCommentLikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserCommentLike mutation op: %q", m.Op())
	}
}

// UserCommentSubscriptionClient is a client for the UserCommentSubscription schema.
type UserCommentSubscriptionClient struct {
	config
}

// NewUserCommentSubscriptionClient returns a client for the UserCommentSubscription from the given config.
func NewUserCommentSubscriptionClient(c config) *UserCommentSubscriptionClient {
	return &UserCommentSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercommentsubscription.Hooks(f(g(h())))`.
func (c *UserCommentSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.UserCommentSubscription = append(c.hooks.UserCommentSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercommentsubscription.Intercept(f(g(h())))`.
func (c *UserCommentSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserCommentSubscription = append(c.inters.UserCommentSubscription, interceptors...)
}

// Create returns a builder for creating a UserCommentSubscription entity.
func (c *UserCommentSubscriptionClient) Create() *UserCommentSubscriptionCreate {
	mutation := newUserCommentSubscriptionMutation(c.config, OpCreate)
	return &UserCommentSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserCommentSubscription entities.
func (c *UserCommentSubscriptionClient) CreateBulk(builders ...*UserCommentSubscriptionCreate) *UserCommentSubscriptionCreateBulk {
	return &UserCommentSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserCommentSubscriptionClient) MapCreateBulk(slice any, setFunc func(*UserCommentSubscriptionCreate, int)) *UserCommentSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCommentSubscriptionCreateBulk{err: fmt.Errorf("calling to UserCommentSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCommentSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCommentSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserCommentSubscription.
func (c *UserCommentSubscriptionClient) Update() *UserCommentSubscriptionUpdate {
	mutation := newUserCommentSubscriptionMutation(c.config, OpUpdate)
	return &UserCommentSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserCommentSubscriptionClient) UpdateOne(ucs *UserCommentSubscription) *UserCommentSubscriptionUpdateOne {
	mutation := newUserCommentSubscriptionMutation(c.config, OpUpdateOne)
	mutation.user = &ucs.UserId
	mutation.comment = &ucs.CommentId
	return &UserCommentSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserCommentSubscription.
func (c *UserCommentSubscriptionClient) Delete() *UserCommentSubscriptionDelete {
	mutation := newUserCommentSubscriptionMutation(c.config, OpDelete)
	return &UserCommentSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UserCommentSubscription.
func (c *UserCommentSubscriptionClient) Query() *UserCommentSubscriptionQuery {
	return &UserCommentSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserCommentSubscription},
		inters: c.Interceptors(),
	}
}

// QueryUser queries the user edge of a UserCommentSubscription.
func (c *UserCommentSubscriptionClient) QueryUser(ucs *UserCommentSubscription) *UserQuery {
	return c.Query().
		Where(usercommentsubscription.UserId(ucs.UserId), usercommentsubscription.CommentId(ucs.CommentId)).
		QueryUser()
}

// QueryComment queries the comment edge of a UserCommentSubscription.
func (c *UserCommentSubscriptionClient) QueryComment(ucs *UserCommentSubscription) *CommentQuery {
	return c.Query().
		Where(usercommentsubscription.UserId(ucs.UserId), usercommentsubscription.CommentId(ucs.CommentId)).
		QueryComment()
}

// Hooks returns the client hooks.
func (c *UserCommentSubscriptionClient) Hooks() []Hook {
	return c.hooks.UserCommentSubscription
}

// Interceptors returns the client interceptors.
func (c *UserCommentSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.UserCommentSubscription
}

func (c *UserCommentSubscriptionClient) mutate(ctx context.Context, m *UserCommentSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCommentSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserCommentSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserCommentSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserCommentSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserCommentSubscription mutation op: %q", m.Op())
	}
}

// UserThreadLikeClient is a client for the UserThreadLike schema.
type UserThreadLikeClient struct {
	config
}

// NewUserThreadLikeClient returns a client for the UserThreadLike from the given config.
func NewUserThreadLikeClient(c config) *UserThreadLikeClient {
	return &UserThreadLikeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userthreadlike.Hooks(f(g(h())))`.
func (c *UserThreadLikeClient) Use(hooks ...Hook) {
	c.hooks.UserThreadLike = append(c.hooks.UserThreadLike, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userthreadlike.Intercept(f(g(h())))`.
func (c *UserThreadLikeClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserThreadLike = append(c.inters.UserThreadLike, interceptors...)
}

// Create returns a builder for creating a UserThreadLike entity.
func (c *UserThreadLikeClient) Create() *UserThreadLikeCreate {
	mutation := newUserThreadLikeMutation(c.config, OpCreate)
	return &UserThreadLikeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserThreadLike entities.
func (c *UserThreadLikeClient) CreateBulk(builders ...*UserThreadLikeCreate) *UserThreadLikeCreateBulk {
	return &UserThreadLikeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserThreadLikeClient) MapCreateBulk(slice any, setFunc func(*UserThreadLikeCreate, int)) *UserThreadLikeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserThreadLikeCreateBulk{err: fmt.Errorf("calling to UserThreadLikeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserThreadLikeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserThreadLikeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserThreadLike.
func (c *UserThreadLikeClient) Update() *UserThreadLikeUpdate {
	mutation := newUserThreadLikeMutation(c.config, OpUpdate)
	return &UserThreadLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserThreadLikeClient) UpdateOne(utl *UserThreadLike) *UserThreadLikeUpdateOne {
	mutation := newUserThreadLikeMutation(c.config, OpUpdateOne)
	mutation.user = &utl.UserId
	mutation.thread = &utl.ThreadId
	return &UserThreadLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserThreadLike.
func (c *UserThreadLikeClient) Delete() *UserThreadLikeDelete {
	mutation := newUserThreadLikeMutation(c.config, OpDelete)
	return &UserThreadLikeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UserThreadLike.
func (c *UserThreadLikeClient) Query() *UserThreadLikeQuery {
	return &UserThreadLikeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserThreadLike},
		inters: c.Interceptors(),
	}
}

// QueryUser queries the user edge of a UserThreadLike.
func (c *UserThreadLikeClient) QueryUser(utl *UserThreadLike) *UserQuery {
	return c.Query().
		Where(userthreadlike.UserId(utl.UserId), userthreadlike.ThreadId(utl.ThreadId)).
		QueryUser()
}

// QueryThread queries the thread edge of a UserThreadLike.
func (c *UserThreadLikeClient) QueryThread(utl *UserThreadLike) *ThreadQuery {
	return c.Query().
		Where(userthreadlike.UserId(utl.UserId), userthreadlike.ThreadId(utl.ThreadId)).
		QueryThread()
}

// Hooks returns the client hooks.
func (c *UserThreadLikeClient) Hooks() []Hook {
	return c.hooks.UserThreadLike
}

// Interceptors returns the client interceptors.
func (c *UserThreadLikeClient) Interceptors() []Interceptor {
	return c.inters.UserThreadLike
}

func (c *UserThreadLikeClient) mutate(ctx context.Context, m *UserThreadLikeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserThreadLikeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserThreadLikeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserThreadLikeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserThreadLikeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserThreadLike mutation op: %q", m.Op())
	}
}

// UserThreadSubscriptionClient is a client for the UserThreadSubscription schema.
type UserThreadSubscriptionClient struct {
	config
}

// NewUserThreadSubscriptionClient returns a client for the UserThreadSubscription from the given config.
func NewUserThreadSubscriptionClient(c config) *UserThreadSubscriptionClient {
	return &UserThreadSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userthreadsubscription.Hooks(f(g(h())))`.
func (c *UserThreadSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.UserThreadSubscription = append(c.hooks.UserThreadSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userthreadsubscription.Intercept(f(g(h())))`.
func (c *UserThreadSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserThreadSubscription = append(c.inters.UserThreadSubscription, interceptors...)
}

// Create returns a builder for creating a UserThreadSubscription entity.
func (c *UserThreadSubscriptionClient) Create() *UserThreadSubscriptionCreate {
	mutation := newUserThreadSubscriptionMutation(c.config, OpCreate)
	return &UserThreadSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserThreadSubscription entities.
func (c *UserThreadSubscriptionClient) CreateBulk(builders ...*UserThreadSubscriptionCreate) *UserThreadSubscriptionCreateBulk {
	return &UserThreadSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserThreadSubscriptionClient) MapCreateBulk(slice any, setFunc func(*UserThreadSubscriptionCreate, int)) *UserThreadSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserThreadSubscriptionCreateBulk{err: fmt.Errorf("calling to UserThreadSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserThreadSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserThreadSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserThreadSubscription.
func (c *UserThreadSubscriptionClient) Update() *UserThreadSubscriptionUpdate {
	mutation := newUserThreadSubscriptionMutation(c.config, OpUpdate)
	return &UserThreadSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserThreadSubscriptionClient) UpdateOne(uts *UserThreadSubscription) *UserThreadSubscriptionUpdateOne {
	mutation := newUserThreadSubscriptionMutation(c.config, OpUpdateOne)
	mutation.user = &uts.UserId
	mutation.thread = &uts.ThreadId
	return &UserThreadSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserThreadSubscription.
func (c *UserThreadSubscriptionClient) Delete() *UserThreadSubscriptionDelete {
	mutation := newUserThreadSubscriptionMutation(c.config, OpDelete)
	return &UserThreadSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for UserThreadSubscription.
func (c *UserThreadSubscriptionClient) Query() *UserThreadSubscriptionQuery {
	return &UserThreadSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserThreadSubscription},
		inters: c.Interceptors(),
	}
}

// QueryUser queries the user edge of a UserThreadSubscription.
func (c *UserThreadSubscriptionClient) QueryUser(uts *UserThreadSubscription) *UserQuery {
	return c.Query().
		Where(userthreadsubscription.UserId(uts.UserId), userthreadsubscription.ThreadId(uts.ThreadId)).
		QueryUser()
}

// QueryThread queries the thread edge of a UserThreadSubscription.
func (c *UserThreadSubscriptionClient) QueryThread(uts *UserThreadSubscription) *ThreadQuery {
	return c.Query().
		Where(userthreadsubscription.UserId(uts.UserId), userthreadsubscription.ThreadId(uts.ThreadId)).
		QueryThread()
}

// Hooks returns the client hooks.
func (c *UserThreadSubscriptionClient) Hooks() []Hook {
	return c.hooks.UserThreadSubscription
}

// Interceptors returns the client interceptors.
func (c *UserThreadSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.UserThreadSubscription
}

func (c *UserThreadSubscriptionClient) mutate(ctx context.Context, m *UserThreadSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserThreadSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserThreadSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserThreadSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserThreadSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserThreadSubscription mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AdminUser, Board, Comment, CommentAttachment, Thread, ThreadTag, ThreadTagging,
		User, UserBoardLike, UserBoardSubscription, UserCommentLike,
		UserCommentSubscription, UserThreadLike, UserThreadSubscription []ent.Hook
	}
	inters struct {
		AdminUser, Board, Comment, CommentAttachment, Thread, ThreadTag, ThreadTagging,
		User, UserBoardLike, UserBoardSubscription, UserCommentLike,
		UserCommentSubscription, UserThreadLike,
		UserThreadSubscription []ent.Interceptor
	}
)
